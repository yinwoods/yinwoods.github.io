<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="yinwoods,yinwoods#163.com"><title>Linux内核模块编程入门 · yinwoods</title><meta name="description" content="首先我们要明确linux下内核编程与平时我们在linux下写的C程序之间的区别，在这里我们把在linux下写一般C程序的过程称之为用户层编程，与之相对的就是我们要学习的内核编程。
首先介绍linux内核，内核指的是一个提供硬件抽象层、磁盘、文件系统控制及多任务等功能的系统软件。我们可以把内核理解为操"><meta name="keywords" content="Hexo,Linux,Python"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">yinwoods</a></h3><div class="description"><p>To Be A Better Man!😈</p></div></div></div><ul class="social-links"><li><a href="http://github.com/https://github.com/yinwoods"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Linux内核模块编程入门</a></h3></div><div class="post-content"><p>首先我们要明确linux下内核编程与平时我们在linux下写的C程序之间的区别，在这里我们把在linux下写一般C程序的过程称之为用户层编程，与之相对的就是我们要学习的内核编程。</p>
<p>首先介绍linux内核，<strong>内核</strong>指的是一个提供硬件抽象层、磁盘、文件系统控制及多任务等功能的系统软件。我们可以把内核理解为操作系统的核心部分（<strong>注意：内核不等于操作系统</strong>）。而linux内核就是linux操作系统的内核。</p>
<p>内核由负责不同功能的内核模块组成，内核模块可以被单独编译，但是不能单独运行，它必须要链接到内核作为内核的一部分在内核空间中运行。内核之所以采用这种结构方式是因为这体现了模块化的思想，在保证内核不会太大的同时，又可以做到模块一旦被加载就和内核中的其他部分一样使用。</p>
<p>用户层编程和内核模块编程的区别：</p>
<p><img src="http://7xlnl2.com1.z0.glb.clouddn.com/post42-difference.jpg" alt="用户层编程与内核模块编程区别"></p>
<p>下面编写一个内核模块中的hello world程序:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//filename: hello.c</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">//这里的三个头文件是编写内核模块程序所必须的</span></div><div class="line"></div><div class="line">MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);</div><div class="line"></div><div class="line"><span class="comment">/*可选</span></div><div class="line"></div><div class="line">MODULE_AUTHOR("yinwoods");</div><div class="line"></div><div class="line">MODULE_DESCRIPTION("This is a simple example!\n");</div><div class="line"></div><div class="line">MODULE_ALIAS("A simplest example");</div><div class="line"></div><div class="line">*/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    printk(KERN_ALERT <span class="string">"hello, I am yinwoods"</span>);</div><div class="line">    <span class="comment">//printk是内核态信息打印函数，功能上与printf类似。不同的是printk具有消息打印机别，这里的KERN_ALERT即为一个消息级别。</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    printk(KERN_ALERT <span class="string">"good bye, kernel\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">module_init(hello_init);</div><div class="line">module_exit(hello_exit);</div></pre></td></tr></table></figure>
<h3 id="module-init-函数和module-exit-函数"><a href="#module-init-函数和module-exit-函数" class="headerlink" title="module_init()函数和module_exit()函数"></a>module_init()函数和module_exit()函数</h3><p><code>module_init(hello_init)</code>是指模块程序从<code>hello_init</code>开始执行，函数参数就是注册函数的函数名。</p>
<p>同理，<code>module_exit(hello_exit)</code>是指模块程序从<code>hello_exit</code>离开，函数参数就是卸载函数的函数名。</p>
<p>这里可以类比C++类中的构造函数与析构函数；也就是说我们一般在<code>module_init()</code>中动态申请内存、中断等资源；而在模块卸载函数<code>module_exit()</code>中回收这些资源。</p>
<p>程序写好了，那么怎么编译运行呢？</p>
<h3 id="内核编写程序的编译运行"><a href="#内核编写程序的编译运行" class="headerlink" title="内核编写程序的编译运行"></a>内核编写程序的编译运行</h3><p>在linux下对内核程序进行编译运行与普通程序是不同的，不是通过g++的命令实现,而是需要我们编写makefile脚本并使用make命令来实现多文件的编译。</p>
<p>makefile是一种脚本，这种脚本主要是用于多文件的编译。它定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译等等。</p>
<p>make是一个解释makefile中指令的命令工具，可以维护具有相互依赖性的源文件，当某些文件发生改变时，它能自动识别出，并只对改动后的文件进行编译。</p>
<h3 id="简单介绍一下如何编写makefile："><a href="#简单介绍一下如何编写makefile：" class="headerlink" title="简单介绍一下如何编写makefile："></a>简单介绍一下如何编写makefile：</h3><p>makefile的规则大体上就是以下格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">target:dependency-file</div><div class="line">    command</div></pre></td></tr></table></figure>
<p>target是一个目标文件，可以是Object File（linux下的.o文件），也可以是最终的执行文件。<br>而dependency-file是生成相应target所需要依赖的文件或者其它的target。<br>command就是最终由make执行的命令。</p>
<p>也就是说我们告诉了make程序需要生成的文件target和它所依赖的dependency-file文件还有执行命令command，那么make程序只需要按照这种方式解析makefile即可。</p>
<h3 id="内核程序的编译运行"><a href="#内核程序的编译运行" class="headerlink" title="内核程序的编译运行"></a>内核程序的编译运行</h3><p>1、编写好makefile文件</p>
<p>2、使用make进行编译</p>
<p>3、编译后使用sudo insmod *.ko 加载模块</p>
<p>4、使用dmesg查看运行结果</p>
<p>5、使用rmmod tiger卸载模块</p>
<p>6、使用make clean删除中间生成的文件</p>
<p>在这里贴出示例程序对应的makefile文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">KERNEL_DIR = /usr/src/linux-headers-$(shell uname -r)/</div><div class="line"><span class="comment">#KERNAL_DIR表示内核源代码的位置。在这里是链接到包含着正在使用内核对应源代码的目录树位置。</span></div><div class="line">PWD := $(shell <span class="built_in">pwd</span>)</div><div class="line"><span class="comment">#PWD指示了当前工作目录并且是我们自己内核模块的源代码位置。</span></div><div class="line"></div><div class="line">obj-m := hello.o</div><div class="line"></div><div class="line"><span class="comment">#需要编译连接多个文件时，只需要在添加。再添加相应的语句即可，如下：</span></div><div class="line"><span class="comment">#obj-m += device1.o</span></div><div class="line"><span class="comment">#obj-m += device2.o</span></div><div class="line"></div><div class="line">all:</div><div class="line">	$(MAKE) -C $(KERNEL_DIR) M=$(PWD) modules</div><div class="line"><span class="comment">#这里是指在包含源代码位置的地方进行make，然后编译$(PWD)目录下的modules。这里允许我们使用所有定义在内核源代码树下的所有规则来编译我们的内核模块。</span></div><div class="line"></div><div class="line">clean:</div><div class="line">	$(MAKE) -C $(KERNEL_DIR) M=$(PWD) clean</div><div class="line">	$(RM) Module.markers modules.order</div></pre></td></tr></table></figure>
<p>按照上述的编译运行步骤，make, insmod hello.ko, dmesg即可看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hello, I am yinwoods</div><div class="line">good bye, kernel</div></pre></td></tr></table></figure>
<p>最后通过rmmod hello 卸载该模块。</p>
<p>因为导师布置的毕设题目是platform虚拟总线下的进程调度，所以这段时间要好好补一补linux内核设备驱动方面知识了。</p>
<p>下一步是实现platform下简单的线程通信。加油！</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-01-14</span><i class="fa fa-tag"></i><a href="/categories/coding/" title="coding" class="tag">coding </a><a href="/tags/linux-cpp/" title="linux, cpp" class="tag">linux, cpp </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://blog.yinwoods.work/2016/01/14/Linux内核模块编程入门/,yinwoods,Linux内核模块编程入门,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2016/01/30/基础排序算法总结/" title="基础排序算法总结" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2015/12/24/windows进程通信方式消息处理机制/" title="windows进程通信方式&amp;消息处理机制" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>