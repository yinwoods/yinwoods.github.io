<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="yinwoods,yinwoods#163.com"><title>Java中的变型 · yinwoods</title><meta name="description" content="什么是变型?维基百科上变型的定义:

变型是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。

许多程序设计语言的类型系统支持子类型。例如，如果Cat是Animal的子类型，那么Cat类型的表达式可用于任何出现Animal类型表达式"><meta name="keywords" content="Hexo,Linux,Python"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">yinwoods</a></h3><div class="description"><p>To Be A Better Man!😈</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/yinwoods"><i class="fa fa-weibo"></i></a></li><li><a href="http://facebook.com/yinwoods"><i class="fa fa-facebook"></i></a></li><li><a href="http://github.com/yinwoods"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li><li><a href="/about">关于</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Java中的变型</a></h3></div><div class="post-content"><h2 id="什么是变型"><a href="#什么是变型" class="headerlink" title="什么是变型?"></a>什么是变型?</h2><p>维基百科上<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98" target="_blank" rel="external">变型</a>的定义:</p>
<blockquote>
<p><strong>变型</strong>是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。</p>
</blockquote>
<p>许多<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E8%AA%9E%E8%A8%80" title="程序设计语言" target="_blank" rel="external">程序设计语言</a>的<a href="https://zh.wikipedia.org/wiki/%E5%9E%8B%E5%88%A5%E7%B3%BB%E7%B5%B1" title="类型系统" target="_blank" rel="external">类型系统</a>支持<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E5%9E%8B%E5%88%A5" title="子类型" target="_blank" rel="external">子类型</a>。例如，如果<code>Cat</code>是<code>Animal</code>的子类型，那么<code>Cat</code>类型的表达式可用于任何出现<code>Animal</code>类型表达式的地方。所谓的<strong>变型</strong>（variance）是指如何根据组成类型之间的子类型关系，来确定更复杂的类型之间（例如<code>Cat</code>列表之于<code>Animal</code>列表，返回值为<code>Cat</code>的函数之于返回值为<code>Animal</code>的函数…等等）的子类型关系。当我们用类型构造出更复杂的类型，原本类型的子类型性质可能被保持、反转、或忽略───取决于<a href="https://zh.wikipedia.org/wiki/%E5%9E%8B%E5%88%A5%E6%A7%8B%E9%80%A0%E5%99%A8" title="类型构造器" target="_blank" rel="external">类型构造器</a>的变型性质。例如在<a href="https://zh.wikipedia.org/wiki/C%E2%99%AF" title="C♯" target="_blank" rel="external">C#</a>中：</p>
<ul>
<li><p><code>IEnumerable&lt;Cat&gt;</code>是<code>IEnumerable&lt;Animal&gt;</code>的子类型，因为类型构造器<code>IEnumerable&lt;T&gt;</code>是协变的（covariant）。注意到复杂类型<code>IEnumerable</code>的子类型关系和其接口中的参数类型是一致的，亦即，参数类型之间的子类型关系被保持住了。</p>
</li>
<li><p><code>Action&lt;Cat&gt;</code>是<code>Action&lt;Animal&gt;</code>的超类型，因为类型构造器<code>Action&lt;T&gt;</code>是逆变的（contravariant）。（在此，<code>Action&lt;T&gt;</code>被用来表示一个参数类型为<code>T</code>或<code>sub-T</code>的<a href="https://zh.wikipedia.org/wiki/%E4%B8%80%E7%B4%9A%E5%87%BD%E6%95%B8" title="一级函数" target="_blank" rel="external">一级函数</a>）。注意到<code>T</code>的子类型关系在复杂类型<code>Action</code>的封装下是反转的，但是当它被视为函数的参数时其子类型关系是被保持的。</p>
</li>
<li><p><code>IList&lt;Cat&gt;</code>或<code>IList&lt;Animal&gt;</code>彼此之间没有子类型关系。因为<code>IList&lt;T&gt;</code>类型构造器是不变的（invariant），所以参数类型之间的子类型关系被忽略了。</p>
</li>
</ul>
<p>“复杂型别” 指的是如容器、函数之类的高级数据结构，因此变型描述的是通过继承关联的容器、函数的赋值兼容性。例如，我们能够将一个返回值为cat列表的方法返回值赋值到animal列表吗？我们能够将Audi列表作为接收cars列表方法的参数吗？</p>
<h2 id="四种变型"><a href="#四种变型" class="headerlink" title="四种变型"></a>四种变型</h2><p>在一门程序设计语言的<a href="https://zh.wikipedia.org/wiki/%E5%9E%8B%E5%88%A5%E7%B3%BB%E7%B5%B1" title="类型系统" target="_blank" rel="external">类型系统</a>中，一个类型规则或者类型构造器是：</p>
<ul>
<li><strong>协变</strong>（covariant），如果它保持了<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E5%9E%8B%E5%88%A5" title="子类型" target="_blank" rel="external">子类型序关系≦</a>。该序关系是：子类型≦基类型。</li>
<li><strong>逆变</strong>（contravariant），如果它逆转了子类型序关系。</li>
<li><strong>不变</strong>（invariant），如果上述两种均不适用。</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>首先考虑数组类型构造器： 从<code>Animal</code>类型，可以得到<code>Animal[]</code>（“animal数组”）。 是否可以把它当作</p>
<ul>
<li>协变：一个<code>Cat[]</code>也是一个<code>Animal[]</code></li>
<li>逆变：一个<code>Animal[]</code>也是一个<code>Cat[]</code></li>
<li>以上二者均不是（不变）？</li>
</ul>
<p>如果要避免类型错误，且数组支持对其元素的读、写操作，那么只有第3个选择是安全的。<code>Animal[]</code>并不是总能当作<code>Cat[]</code>，因为当一个客户读取数组并期望得到一个<code>Cat</code>，但<code>Animal[]</code>中包含的可能是个<code>Dog</code>。所以逆变规则是不安全的。</p>
<p>反之，一个<code>Cat[]</code>也不能被当作一个<code>Animal[]</code>。因为总是可以把一个<code>Dog</code>放到<code>Animal[]</code>中。在协变数组，这就不能保证是安全的，因为背后的存储可以实际是<code>Cat[]</code>。因此协变规则也不是安全的—数组构造器应该是<strong>不变</strong>。注意，这仅是可写（mutable）数组的问题；对于不可写（只读）数组，协变规则是安全的。</p>
<p>这示例了一般现像。只读数据类型是协变的；只写数据类型是逆变的。可读可写类型应是“不变”的。</p>
<p>Java中泛型是不变的，可有时需要实现逆变与协变，怎么办呢？这时，通配符?派上了用场：</p>
<p><code>&lt;? extends&gt;</code>实现了泛型的协变，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;? extends Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div></pre></td></tr></table></figure></p>
<p><code>&lt;? super&gt;</code>实现了泛型的逆变，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;? <span class="keyword">super</span> Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</div></pre></td></tr></table></figure></p>
<p>extends确定了泛型的上界，而super确定了泛型的下界。</p>
<h3 id="Java中的协变"><a href="#Java中的协变" class="headerlink" title="Java中的协变"></a>Java中的协变</h3><blockquote>
<p>如果 <code>B</code> 是 <code>A</code> 的子类型, 那么 <code>GenericType&lt;B&gt;</code> 是 <code>GenericType&lt;? extends A&gt;</code> 的子类型.</p>
</blockquote>
<p>早期版本的Java不包含<a href="https://zh.wikipedia.org/wiki/%E6%B3%9B%E5%9E%8B" title="泛型" target="_blank" rel="external">泛型</a>（generics，即参数化多态）。在这样的设置下，使数组为“不变”将导致许多有用的多态程序被排除。</p>
<p>例如，考虑一个用于重排（shuffle）数组的函数，或者测试两个数组相等的函数，使用<code>Object</code>与<code>equals</code>方法. 函数的实现并不依赖于数组元素的确切类型，因此可以写一个单独的实现而适用于所有的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalArrays</span> <span class="params">(Object[] a1, Object[] a2)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffleArray</span><span class="params">(Object[] a)</span></span>;</div></pre></td></tr></table></figure></p>
<p>然而，如果数组类型被处理为“不变”，那么它仅能用于确切为<code>Object[]</code>类型的数组。对于字符串数组等就不能做重排操作了。</p>
<p>所以，Java把数组类型处理为协变。在Java中，<code>String[]</code>是<code>Object[]</code>的子类型。</p>
<p>如前文所述，协变数组在写入数组的操作时会出问题。Java为此把每个数组对像在创建时附标一个类型。 每当向数组存入一个值，编译器插入一段代码来检查该值的运行时类型是否等于数组的运行时类型。如果不匹配，会抛出一个<code>ArrayStoreException</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a 是单元素的 String 数组</span></div><div class="line">String[] a = <span class="keyword">new</span> String[<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// b 是 Object 的数组</span></div><div class="line">Object[] b = a;</div><div class="line"></div><div class="line"><span class="comment">// 向 b 中赋一个整数。如果 b 确实是 Object 的数组，这是可能的；然而它其实是个 String 的数组，因此会发生 java.lang.ArrayStoreException</span></div><div class="line">b[<span class="number">0</span>] = <span class="number">1</span>;</div></pre></td></tr></table></figure></p>
<p>在上例中，可以从b中安全地读。仅在写入数组时可能会遇到麻烦。</p>
<p>这个方法的缺点是留下了运行时错误的可能，而一个更严格的<a href="https://zh.wikipedia.org/wiki/%E5%9E%8B%E5%88%A5%E7%B3%BB%E7%B5%B1" title="类型系统" target="_blank" rel="external">类型系统</a>本可以在编译时识别出该错误。这个方法还有损性能，因为在运行时要运行额外的类型检查。</p>
<p>Java有了泛型后，有了类型安全的编写这种多态函数。数组比较与重排可以给定参数类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">equalArrays</span> <span class="params">(T[] a1, T[] a2)</span></span>;</div><div class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">shuffleArray</span><span class="params">(T[] a)</span></span>;</div></pre></td></tr></table></figure></p>
<h3 id="协变容器"><a href="#协变容器" class="headerlink" title="协变容器"></a>协变容器</h3><p>Java允许子类型（协变）泛型类型，但它会严格限制可以“流入和流出“的泛型类型。换句话说，具有类型参数的返回值的方法是可访问的，而具有类型参数的输入参数的方法是不可访问的。</p>
<p>您可以为子类型赋值超类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person :&gt; Joe :&gt; JoeJr</span></div><div class="line">List&lt;? extends Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;Joe&gt;(); <span class="comment">// OK，没问题👌</span></div><div class="line">List&lt;? extends Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;JoeJr&gt;(); <span class="comment">// OK，没问题👌</span></div><div class="line">List&lt;? extends Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;Person&gt;(); <span class="comment">// COMPILE ERROR</span></div></pre></td></tr></table></figure>
<p>也可从协变容器中 <em>读出</em> 超类型:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person :&gt; Joe :&gt; JoeJr</span></div><div class="line">List&lt;? extends Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">Joe j = joes.get(<span class="number">0</span>); <span class="comment">// OK，没问题👌</span></div><div class="line">Person p = joes.get(<span class="number">0</span>); <span class="comment">// OK，没问题👌</span></div><div class="line">JoeJr jr = joes.get(<span class="number">0</span>); <span class="comment">// compile error (you don't know what subtype of Joe is in the list)</span></div></pre></td></tr></table></figure></p>
<p>但向协变容器 <em>写入</em> 超类型是禁止的。在下例的代码中, 如果其他方法向 <code>List&lt;? extends Person&gt;</code> 参数中加入 <code>Jill</code>，<code>List&lt;Joe&gt;</code> 的调用房将会 <em>混乱</em> 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person &gt; Joe &gt; JoeJr</span></div><div class="line">List&lt;? extends Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">joes.add(<span class="keyword">new</span> Joe());  <span class="comment">// compile error (无法知道joes接受Joe的什么子类型)</span></div><div class="line">joes.add(<span class="keyword">new</span> JoeJr()); <span class="comment">// compile error (ditto)</span></div><div class="line">joes.add(<span class="keyword">new</span> Person()); <span class="comment">// compile error (intuitive)</span></div><div class="line">joes.add(<span class="keyword">new</span> Object()); <span class="comment">// compile error (intuitive)</span></div></pre></td></tr></table></figure></p>
<h2 id="Java中的不变"><a href="#Java中的不变" class="headerlink" title="Java中的不变"></a>Java中的不变</h2><blockquote>
<p>如果 <code>A</code> 是 <code>B</code> 的超类型, 那么 <code>GenericType&lt;A&gt;</code> <strong>不是</strong> <code>GenericType&lt;B&gt;</code> 的超类型，以及反之亦然。</p>
</blockquote>
<p>也就是说两种类型互不关联，且在任何条件下都不能互换。</p>
<h3 id="不变容器"><a href="#不变容器" class="headerlink" title="不变容器"></a>不变容器</h3><p>在Java中，不变量可能是您将遇到的泛型的第一个例子，并且是最直观的。类型参数的方法可以像人们期望的那样使用。可以访问类型参数的所有方法。</p>
<p>他们无法交换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person :&gt; Joe :&gt; JoeJr</span></div><div class="line">List&lt;Person&gt; p = <span class="keyword">new</span> ArrayList&lt;Joe&gt;(); <span class="comment">// COMPILE ERROR (a bit counterintuitive, but remember List&lt;Person&gt; is invariant)</span></div><div class="line">List&lt;Joe&gt; j = <span class="keyword">new</span> ArrayList&lt;Person&gt;(); <span class="comment">// COMPILE ERROR</span></div></pre></td></tr></table></figure></p>
<p>但可以向容器中添加对应对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person :&gt; Joe :&gt; JoeJr</span></div><div class="line">List&lt;Person&gt; p = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">p.add(<span class="keyword">new</span> Person()); <span class="comment">// OK</span></div><div class="line">p.add(<span class="keyword">new</span> Joe()); <span class="comment">// OK</span></div><div class="line">p.add(<span class="keyword">new</span> JoeJr()); <span class="comment">// OK</span></div></pre></td></tr></table></figure></p>
<p>也可以从容器中读取对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person :&gt; Joe :&gt; JoeJr</span></div><div class="line">List&lt;Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">Joe j = joes.get(<span class="number">0</span>); <span class="comment">// OK</span></div><div class="line">Person p = joes.get(<span class="number">0</span>); <span class="comment">// OK</span></div></pre></td></tr></table></figure></p>
<h2 id="Java中的逆变"><a href="#Java中的逆变" class="headerlink" title="Java中的逆变"></a>Java中的逆变</h2><blockquote>
<p>如果 <code>A</code> 是 <code>B</code> 的超类型, 那么 <code>GenericType&lt;A&gt;</code> 是 <code>GenericType&lt;? super B&gt;</code> 的超类型。</p>
</blockquote>
<h3 id="逆变容器"><a href="#逆变容器" class="headerlink" title="逆变容器"></a>逆变容器</h3><p>逆变容器表现同协变容器相反，也就是说，可以具有类型参数的输入参数的方法是可访问的，而具有类型参数的返回值的方法是不可访问的。</p>
<p>可以为超类型赋值子类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person &gt; Joe &gt; JoeJr</span></div><div class="line">List&lt;? <span class="keyword">super</span> Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;Joe&gt;();  <span class="comment">// OK</span></div><div class="line">List&lt;? <span class="keyword">super</span> Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;Person&gt;(); <span class="comment">// OK</span></div><div class="line">List&lt;? <span class="keyword">super</span> Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;JoeJr&gt;(); <span class="comment">// COMPILE ERROR</span></div></pre></td></tr></table></figure></p>
<p>但不能从容器中读出特定类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person &gt; Joe &gt; JoeJr</span></div><div class="line">List&lt;? <span class="keyword">super</span> Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">Joe j = joes.get(<span class="number">0</span>); <span class="comment">// compile error (0位置的元素可以是Object或Person)</span></div><div class="line">Person p = joes.get(<span class="number">0</span>); <span class="comment">// compile error (ditto)</span></div><div class="line">Object o = joes.get(<span class="number">0</span>); <span class="comment">// 能够执行，因为Java中一切皆对象</span></div></pre></td></tr></table></figure></p>
<p>可以向其添加直接子类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person &gt; Joe &gt; JoeJr</span></div><div class="line">List&lt;? <span class="keyword">super</span> Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">joes.add(<span class="keyword">new</span> JoeJr()); <span class="comment">// allowed</span></div></pre></td></tr></table></figure></p>
<p>但不能向其添加超类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person &gt; Joe &gt; JoeJr</span></div><div class="line">List&lt;? <span class="keyword">super</span> Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">joes.add(<span class="keyword">new</span> Person()); <span class="comment">// compile error (again, could be a list of Object or Person or Joe)</span></div><div class="line">joes.add(<span class="keyword">new</span> Object()); <span class="comment">// compile error (ditto)</span></div></pre></td></tr></table></figure></p>
<h2 id="具有-N-Type-参数结构的协变"><a href="#具有-N-Type-参数结构的协变" class="headerlink" title="具有 N-Type 参数结构的协变"></a>具有 N-Type 参数结构的协变</h2><p>对于如Functions这种更复杂的类型，规则同样适用，只是需要考虑多个参数规则:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person &gt; Joe &gt; JoeJr</span></div><div class="line"></div><div class="line"><span class="comment">// 不变</span></div><div class="line">Function&lt;Person, Joe&gt; personToJoe = <span class="keyword">null</span>;</div><div class="line">Function&lt;Joe, JoeJr&gt; joeToJoeJr = <span class="keyword">null</span>;</div><div class="line">personToJoe = joeToJoeJr; <span class="comment">// COMPILE ERROR (personToJoe 是不变的)</span></div><div class="line"></div><div class="line"><span class="comment">// 协变</span></div><div class="line">Function&lt;? extends Person, ? extends Joe&gt; personToJoe = <span class="keyword">null</span>; <span class="comment">// 协变</span></div><div class="line">Function&lt;Joe, JoeJr&gt; joeToJoeJr = <span class="keyword">null</span>;</div><div class="line">personToJoe = joeToJoeJr;  <span class="comment">// OK</span></div><div class="line"></div><div class="line"><span class="comment">// 逆变</span></div><div class="line">Function&lt;? <span class="keyword">super</span> Joe, ? <span class="keyword">super</span> JoeJr&gt; joeToJoeJr = <span class="keyword">null</span>; <span class="comment">// 逆变</span></div><div class="line">Function&lt;? <span class="keyword">super</span> Person, ? <span class="keyword">super</span> Joe&gt; personToJoe = <span class="keyword">null</span>;</div><div class="line">joeToJoeJr = personToJoe; <span class="comment">// OK</span></div></pre></td></tr></table></figure></p>
<h2 id="协变与继承"><a href="#协变与继承" class="headerlink" title="协变与继承"></a>协变与继承</h2><p>Java允许使用协变返回类型和异常类型重载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="function">Person <span class="title">get</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Joe</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="function">JoeJr <span class="title">get</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoeImpl</span> <span class="keyword">implements</span> <span class="title">Joe</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> JoeJr <span class="title">get</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 重载</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125; <span class="comment">// 重载</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是尝试使用协变参数重载方法只会导致重写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Person p)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Joe</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Joe j)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoeImpl</span> <span class="keyword">implements</span> <span class="title">Joe</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Person p)</span> </span>&#123;&#125;  <span class="comment">// overloaded</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Joe j)</span> </span>&#123;&#125; <span class="comment">// overloaded</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h2 id="Final-Thoughts"><a href="#Final-Thoughts" class="headerlink" title="Final Thoughts"></a>Final Thoughts</h2><p>协变为J​​ava带来了额外的复杂性。虽然协变的规则很容易理解，但关于类型参数方法的可访问性的规则是违反直觉的。理解它们需要暂停手头的工作，额外思考。</p>
<p>但是，我的日常经验是，细微差别通常不会受到影响：</p>
<ul>
<li>我不记得一个我必须声明逆变的实例，我很少遇到它们（虽然它们确实存在）。</li>
<li>协变论证似乎更常见，但同时它们也更容易推理。</li>
</ul>
<p><strong>总结:</strong> 协变在日常编程中提供了适度的便利，特别是当需要与子类型的兼容性时（这在OOP中经常出现）。使用协变、逆变时主要参考PECS（Producer Extends Consumer Super）原则：</p>
<ul>
<li>频繁往外读取内容的，适合用上界Extends（协变）。</li>
<li>经常往里插入的，适合用下界Super（逆变）。</li>
</ul>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://llorllale.github.io/java-variance/#fn:2" target="_blank" rel="external">java-variance</a><br><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98" target="_blank" rel="external">协变与逆变</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-04-28</span><i class="fa fa-comment-o"></i><a href="/2019/04/28/Java中的变型/#comments">评论</a><i class="fa fa-tag"></i><a href="/categories/coding/" title="coding" class="tag">coding </a><a href="/tags/Java-变型/" title="Java 变型" class="tag">Java 变型 </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://blog.yinwoods.work/2019/04/28/Java中的变型/,yinwoods,Java中的变型,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2019/05/19/Go实现一个读写锁/" title="Go实现一个读写锁" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2018/06/03/K8S基本组件及执行流程/" title="k8s基本组件及执行流程" class="btn">下一篇</a></li></ul></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'yinwoods';
var disqus_identifier = '2019/04/28/Java中的变型/';
var disqus_title = 'Java中的变型';
var disqus_url = 'http://blog.yinwoods.work/2019/04/28/Java中的变型/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//yinwoods.disqus.com/count.js" async></script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>