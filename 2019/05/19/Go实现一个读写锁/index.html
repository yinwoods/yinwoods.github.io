<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="yinwoods,yinwoods#163.com"><title>Go实现一个读写锁 · yinwoods</title><meta name="description" content="当处理并发时，锁是最常用的编程语言工具，对于大多数应用而言，仅在使用数据时加锁，使用后释放即可。然而，对于一些对性能要求比较高的并发实现，锁的使用方式需要作出对应的优化。例如锁的 粒度 经常用于确保线程在尽可能短的时间内独占。
此外，使用锁时一个常用优化方法是使用 读写锁 ，本文即探讨读写锁的原理并"><meta name="keywords" content="Hexo,Linux,Python"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">yinwoods</a></h3><div class="description"><p>To Be A Better Man!😈</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/yinwoods"><i class="fa fa-weibo"></i></a></li><li><a href="http://facebook.com/yinwoods"><i class="fa fa-facebook"></i></a></li><li><a href="http://github.com/yinwoods"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li><li><a href="/about">关于</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Go实现一个读写锁</a></h3></div><div class="post-content"><p>当处理并发时，锁是最常用的编程语言工具，对于大多数应用而言，仅在使用数据时加锁，使用后释放即可。然而，对于一些对性能要求比较高的并发实现，锁的使用方式需要作出对应的优化。例如锁的 <em>粒度</em> 经常用于确保线程在尽可能短的时间内独占。</p>
<p>此外，使用锁时一个常用优化方法是使用 <em>读写锁</em> ，本文即探讨读写锁的原理并给出相关实现。所有的代码都可以通过 <a href="https://github.com/eliben/code-for-blog/tree/master/2019/rwlocks" target="_blank" rel="external">on GitHub</a>访问。同时，文章的结尾给出了性能测试相关的方法。</p>
<p>本文的撰写目的是为了研究探讨读写锁，如果需要在代码中使用读写锁，Go语言本身已经内置了一个高性能的读写锁：<code>sync.RWMutex</code>。实际上，本文也将探索它的实现。</p>
<p><img src="https://eli.thegreenplace.net/images/2019/rwlock.png" alt=""></p>
<h2 id="读写锁产生的动因"><a href="#读写锁产生的动因" class="headerlink" title="读写锁产生的动因"></a>读写锁产生的动因</h2><p>读写锁产生的动因是为了在无线程写数据的情况下，多个线程能够并发地共享该数据。普通锁并不会区分读线程或者写线程，因此当多个线程需要读取数据时，每个线程都必须先要对该数据上锁，浪费了大量资源。</p>
<p>读写锁相对于普通锁的单个 <em>lock</em> 方法，它有两个方法，一个用于读者、一个用于写者。只要写者没有持有锁，多个读者即可共享数据。</p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>下面实现一个简单的读写锁，使用counter记录读者数量。本文接下来的所有读写锁实现都会实现该接口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> RWLocker <span class="keyword">interface</span> &#123;</div><div class="line">    RLock()    <span class="comment">// 读者获取锁</span></div><div class="line">    RUnlock()  <span class="comment">// 读者释放锁</span></div><div class="line">    WLock()    <span class="comment">// 写者获取锁</span></div><div class="line">    WUnlock()  <span class="comment">// 写者释放锁</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应锁的结构为：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ReaderCountRWLock <span class="keyword">struct</span> &#123;</div><div class="line">    m           sync.Mutex</div><div class="line">    readerCount <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>counter用于记录持有锁的读者数量，读者获取锁、释放锁的逻辑比较简单：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountRWLock)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.m.Lock()</div><div class="line">    l.readerCount++</div><div class="line">    l.m.Unlock()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountRWLock)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.m.Lock()</div><div class="line">    l.readerCount--</div><div class="line">    l.m.Unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>写者获取锁与释放锁的实现则复杂一些，写者在获取锁时必须等待持有锁的读者全部释放锁，代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountRWLock)</span> <span class="title">WLock</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        l.m.Lock()</div><div class="line">        <span class="keyword">if</span> l.readerCount &gt; <span class="number">0</span> &#123;</div><div class="line">            l.m.Unlock()</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">break</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>写者对mutex上锁，同时检查是否存在读者持有锁，如果存在，写者释放mutexx并再次尝试，这也叫 <em>自旋</em> 。如果没有持有锁的读者，WLock将会结束，同时不释放锁，从而读者将无法再持有锁，写者释放锁的逻辑则比较直观：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountRWLock)</span> <span class="title">WUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.m.Unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样的实现方法是我目前能够想到的最简单的方法，它的性能有待优化，例如：当读者持有锁时，写者获取锁的实现会持续自旋，不断的获取锁与释放锁这一过程对CPU的计算能力来说是一种额外的消耗。如果我们能够使写者更高效地等待，那读写锁的性能也将获得提升。</p>
<h2 id="使用条件变量实现高效等待"><a href="#使用条件变量实现高效等待" class="headerlink" title="使用条件变量实现高效等待"></a>使用条件变量实现高效等待</h2><p>条件变量的模式是“获取mutex，检查，如果未准备好则释放mutex”，而这正是我们需要的。因此改进后的读写锁实现是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ReaderCountCondRWLock <span class="keyword">struct</span> &#123;</div><div class="line">    readerCount <span class="keyword">int</span></div><div class="line">    c           *sync.Cond</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你在好奇读写锁中的mutex在哪里，不用担心，Go中，<code>sync.Cond</code> 内嵌一个mutex，这个结构体需要一个构造函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderCountCondRWLock</span><span class="params">()</span> *<span class="title">ReaderCountCondRWLock</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> &amp;ReaderCountCondRWLock&#123;<span class="number">0</span>, sync.NewCond(<span class="built_in">new</span>(sync.Mutex))&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是读者获取锁、释放锁的相关实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountCondRWLock)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.L.Lock()</div><div class="line">    l.readerCount++</div><div class="line">    l.c.L.Unlock()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountCondRWLock)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.L.Lock()</div><div class="line">    l.readerCount--</div><div class="line">    <span class="keyword">if</span> l.readerCount == <span class="number">0</span> &#123;</div><div class="line">        l.c.Signal()</div><div class="line">    &#125;</div><div class="line">    l.c.L.Unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与上一版读写锁实现的区别仅在于这里在最后一个读者释放锁的时候会在条件变量上发出信号。写者获取锁的实现方式为：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountCondRWLock)</span> <span class="title">WLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.L.Lock()</div><div class="line">    <span class="keyword">for</span> l.readerCount &gt; <span class="number">0</span> &#123;</div><div class="line">        l.c.Wait()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的Wait过程仍然处于循环中，因为极有可能在读者发出信号之后、写者获取锁之前，另一个读者先拿到锁。</p>
<p>写者释放锁的过程：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountCondRWLock)</span> <span class="title">WUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.Signal()</div><div class="line">    l.c.L.Unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你能理解Signal为什么是需要的吗？缺少它，在特定情况下将会导致死锁：如果两个写者都在等待条件变量，在其中一个获取锁后，另一个将会继续等待，在缺少后续读者发送信号的情况下，这个写者将会永久等待，因此有必要在写着释放锁的时候发出信号。</p>
<p>这一实现比上一版的视线更为高效，因为避免了自旋的过程，尽管这里仍然又一个循环，但它会在Wait执行时阻塞，仅当竞争时才会再次执行循环。</p>
<p>需要注意的是，这里提到的“更高效”并没有相应的数据支撑，因为对上述代码执行性能测试过于复杂，且性能会随着测试样例的变化而变化。后文将会针对性能测试给出说明。</p>
<h2 id="Counted-信号量"><a href="#Counted-信号量" class="headerlink" title="Counted 信号量"></a>Counted 信号量</h2><p>另一种实现读写锁的优雅方式时通过 <em>counting 信号量</em> 实现。在Go中，<code>golang.org/x/sync/semaphore</code>包提供了相关的实现。构造方法与读者获取锁、释放锁的实现如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> maxWeight <span class="keyword">int64</span> = <span class="number">1</span> &lt;&lt; <span class="number">30</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> SemaRWLock <span class="keyword">struct</span> &#123;</div><div class="line">    s *semaphore.Weighted</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// NewSemaRWLock creates a new SemaRWLock.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSemaRWLock</span><span class="params">()</span> *<span class="title">SemaRWLock</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> &amp;SemaRWLock&#123;semaphore.NewWeighted(maxWeight)&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *SemaRWLock)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.s.Acquire(context.Background(), <span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *SemaRWLock)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.s.Release(<span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>写者仅仅是获取整个maxWeight, 从而保证仅有一个写锁能够获取信号量。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *SemaRWLock)</span> <span class="title">WLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.s.Acquire(context.Background(), maxWeight)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *SemaRWLock)</span> <span class="title">WUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.s.Release(maxWeight)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种实现方式非常简洁，在实际测试时，可能是因为 semaphore.Weighted 不适合特定的测试样例，这个方法的性能甚至还没有第一版实现的性能好。</p>
<h2 id="读者优先-vs-写者优先"><a href="#读者优先-vs-写者优先" class="headerlink" title="读者优先 vs. 写者优先"></a>读者优先 vs. 写者优先</h2><p>上述的三种实现都存在一个问题：当读者数量很大时，可能会导致写者饥饿。例如，第一版实现中 readerCount 为0时，写者才能够获取锁，假设有两个活跃的读者以及一个等待的写者，在写者等待一个读者释放锁的过程中，另一个读者可能又会获取锁</p>
<p>这也被叫做 <em>读者优先</em>, 或者 <em>写者饥饿</em> 。下面我们将实现写者优先的相关逻辑。</p>
<h2 id="简单的写者优先读写锁"><a href="#简单的写者优先读写锁" class="headerlink" title="简单的写者优先读写锁"></a>简单的写者优先读写锁</h2><p>实现源于 <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock" target="_blank" rel="external">Wikipedia</a>。首先，数据结构与构造函数如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> WritePreferRWLock <span class="keyword">struct</span> &#123;</div><div class="line">    readerCount <span class="keyword">int</span></div><div class="line">    hasWriter   <span class="keyword">bool</span></div><div class="line">    c           *sync.Cond</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWritePreferRWLock</span><span class="params">()</span> *<span class="title">WritePreferRWLock</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> &amp;WritePreferRWLock&#123;<span class="number">0</span>, <span class="literal">false</span>, sync.NewCond(<span class="built_in">new</span>(sync.Mutex))&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 readerCount 仍然指代持有锁的读者数量, 但我们添加了一个新的字段 - hasWriter; 当有写者等待获取锁的时候，它的值为true。读者获取锁与释放锁的逻辑如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferRWLock)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.L.Lock()</div><div class="line">    <span class="keyword">for</span> l.hasWriter &#123;</div><div class="line">        l.c.Wait()</div><div class="line">    &#125;</div><div class="line">    l.readerCount++</div><div class="line">    l.c.L.Unlock()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferRWLock)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.L.Lock()</div><div class="line">    l.readerCount--</div><div class="line">    <span class="keyword">if</span> l.readerCount == <span class="number">0</span> &#123;</div><div class="line">        l.c.Signal()</div><div class="line">    &#125;</div><div class="line">    l.c.L.Unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当读者尝试获取锁时，会首先检查是否有写者等待获取锁，如果有的话将会让出获取锁的权限，保证写者先获取锁。</p>
<p>在缩放锁的时候，最后一个读者会发出信号，触发在等待的线程执行。</p>
<p>写者获取锁、释放锁的相关实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferRWLock)</span> <span class="title">WLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.L.Lock()</div><div class="line">    <span class="keyword">for</span> l.hasWriter &#123;</div><div class="line">        l.c.Wait()</div><div class="line">    &#125;</div><div class="line">    l.hasWriter = <span class="literal">true</span></div><div class="line">    <span class="keyword">for</span> l.readerCount &gt; <span class="number">0</span> &#123;</div><div class="line">        l.c.Wait()</div><div class="line">    &#125;</div><div class="line">    l.c.L.Unlock()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferRWLock)</span> <span class="title">WUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.L.Lock()</div><div class="line">    l.hasWriter = <span class="literal">false</span></div><div class="line">    l.c.Broadcast()</div><div class="line">    l.c.L.Unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>写者将会首先检查是否有其他写者在等待，不同于之前的实现，这里写者在WLock与WUnlock之间不再持有mutex，取而代之，mutex仅用于控制共享结构的访问，hasWriter 字段不仅表示有写者在等待锁，也表示写者正在使用锁，当hashWriter为true时，不再有新的读者能够获取到锁。</p>
<p>在 WUnlock 中, 写者将 hasWriter 置为 false，同时广播信号。这里使用Broadcast而不是Signal是因为可能存在多个读者等待，而我们期望唤醒所有等待的读者。</p>
<h2 id="更高效的写者优先读写锁实现"><a href="#更高效的写者优先读写锁实现" class="headerlink" title="更高效的写者优先读写锁实现"></a>更高效的写者优先读写锁实现</h2><p>上述的实现都比较简洁，但性能表现却不够好。因此，这里我们研究下Go自身读写锁的实现。</p>
<p>实现的总体目标是使读者能够尽快获取锁，同时要保证写优先。</p>
<p>首先是结构体与构造方法的实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> WritePreferFastRWLock <span class="keyword">struct</span> &#123;</div><div class="line">    w sync.Mutex</div><div class="line">    writerWait <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">    readerWait <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">    numPending <span class="keyword">int32</span>         <span class="comment">// 尝试持有锁或已经持有锁的读者数量 </span></div><div class="line">    readersDeparting <span class="keyword">int32</span>   <span class="comment">// 在写者持有锁之前获取锁的读者数量（读者释放锁，也会随之减1）</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> maxReaders <span class="keyword">int32</span> = <span class="number">1</span> &lt;&lt; <span class="number">30</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWritePreferFastRWLock</span><span class="params">()</span> *<span class="title">WritePreferFastRWLock</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> l WritePreferFastRWLock</div><div class="line">    l.writerWait = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</div><div class="line">    l.readerWait = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</div><div class="line">    <span class="keyword">return</span> &amp;l</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mutex w不会被读者所使用，它存在的作用是为写者提供互斥，稍后再介绍它的具体用法。numPending用于表示有多少个读者持有锁（类似上文中的readerCount），但它同时也被写者使用。写者将该字段减去maxReaders，如果得到一个负数就表明一个写者正在使用锁，通过原子操作访问该字段，因此不再需要锁。<br>下面介绍读者相关方法的实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferFastRWLock)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;l.numPending, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</div><div class="line">        &lt;-l.readerWait</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferFastRWLock)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> r := atomic.AddInt32(&amp;l.numPending, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">if</span> atomic.AddInt32(&amp;l.readersDeparting, <span class="number">-1</span>) == <span class="number">0</span> &#123;</div><div class="line">            l.writerWait &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读者获取锁时会对numPending加1，如果numPending是非负数，表明没有写者等待持有锁或正持有锁，因此读者可以继续操作。读者获取锁的方法执行极其频繁，而这里只是用了一个原子操作、一个条件判断，因此速度极快。</p>
<p>如果numPending是负数，表明写者正在等待获取锁或已经获取锁，因此读者将会让出权限，保持等待，这个操作是通过在一个无缓冲channel上等待实现的。</p>
<p>当读者释放锁时，它将numPending减1，如果没有写者等待，执行结束；如果有写者等待，readersDeparting字段用于告知写者一个读者已经释放锁。</p>
<p>写者获取锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferFastRWLock)</span> <span class="title">WLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.w.Lock()</div><div class="line">    r := atomic.AddInt32(&amp;l.numPending, -maxReaders) + maxReaders</div><div class="line">    <span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;l.readersDeparting, r) != <span class="number">0</span> &#123;</div><div class="line">        &lt;-l.writerWait</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>w mutex用于保证仅有一个写者在任意时间内获取锁。第二行复杂一些，它完成两件事：</p>
<ol>
<li><p>通过执行numPending减maxReaders告知读者存在一个写者等待</p>
</li>
<li><p>通过执行加maxReaders操作，获取有多少个尝试持有锁或持有锁的读者</p>
</li>
</ol>
<p>接下来，如果有任意数量尝试持有锁或持有锁的读者(r != 0)，它将对应数值加入readersDeparting中，——这让读者在解除写者等待前知道有多少个尝试持有锁或持有锁的读者，当最后一个持有锁的读者释放时，函数将返回（写者持有锁），其他写者因为w而陷入等待，而读者则等待numPending变为非负数才能获取锁。</p>
<p>写者释放锁：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferFastRWLock)</span> <span class="title">WUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    r := atomic.AddInt32(&amp;l.numPending, maxReaders)</div><div class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</div><div class="line">        l.readerWait &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line">    &#125;</div><div class="line">    l.w.Unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再一次，通过加maxReaders，写者能够告诉未来的读者已经没有写者还处于等待获取锁的过程中了。r表示等待获取锁的读者数量，写者通过发送r个空对象到readerWait中唤醒所有等待的读者，最后对w解锁，给予后续写者上锁的机会。</p>
<p>这里主要是readersDeparting不太好理解，为了更好的理解它，假设有如下操作：</p>
<ol>
<li>两个读者获取锁（numPending = 2，readersDeparting = 0）</li>
<li>一个写者获取锁(numPending = 2 - MAX, readersDeparting = 2)</li>
<li>一个读者获取锁（numPending = 3 - MAX, readersDeparting = 2）</li>
</ol>
<p>可见，readersDeparting主要用于记录写者上锁前就已经持有锁的读者数量，后续这些这些读者释放锁时，readersDeparting也会随之减少，当它变为0时，恰好说明写者之前获取锁的所有读者均已经释放锁。</p>
<h2 id="后续-性能测试方法"><a href="#后续-性能测试方法" class="headerlink" title="后续: 性能测试方法"></a>后续: 性能测试方法</h2><p>性能测试相关方法的代码位于<a href="https://github.com/eliben/code-for-blog/blob/master/2019/rwlocks/rwlock_test.go" target="_blank" rel="external">GitHub</a>。它的目的是测试正确性，因此它检查多个读者与写者执行的正确性。在执行性能测试时，会记录每个读者与写者获取锁的等待时间，最后打印平均时间。</p>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://eli.thegreenplace.net/2019/implementing-reader-writer-locks/" target="_blank" rel="external">Implementing reader-writer locks</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-05-19</span><i class="fa fa-comment-o"></i><a href="/2019/05/19/Go实现一个读写锁/#comments">评论</a><i class="fa fa-tag"></i><a href="/categories/coding/" title="coding" class="tag">coding </a><a href="/tags/Go-读写锁/" title="Go 读写锁" class="tag">Go 读写锁 </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://blog.yinwoods.work/2019/05/19/Go实现一个读写锁/,yinwoods,Go实现一个读写锁,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2019/05/26/深度理解git-rebase/" title="深度理解git rebase" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2019/04/28/Java中的变型/" title="Java中的变型" class="btn">下一篇</a></li></ul></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'yinwoods';
var disqus_identifier = '2019/05/19/Go实现一个读写锁/';
var disqus_title = 'Go实现一个读写锁';
var disqus_url = 'http://blog.yinwoods.work/2019/05/19/Go实现一个读写锁/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//yinwoods.disqus.com/count.js" async></script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>