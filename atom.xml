<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yinwoods</title>
  <subtitle>To Be A Better Man!😈</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.yinwoods.work/"/>
  <updated>2019-05-19T05:24:41.791Z</updated>
  <id>http://blog.yinwoods.work/</id>
  
  <author>
    <name>yinwoods</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go实现一个读写锁</title>
    <link href="http://blog.yinwoods.work/2019/05/19/Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>http://blog.yinwoods.work/2019/05/19/Go实现一个读写锁/</id>
    <published>2019-05-19T05:16:00.000Z</published>
    <updated>2019-05-19T05:24:41.791Z</updated>
    
    <content type="html"><![CDATA[<p>当处理并发时，锁是最常用的编程语言工具，对于大多数应用而言，仅在使用数据时加锁，使用后释放即可。然而，对于一些对性能要求比较高的并发实现，锁的使用方式需要作出对应的优化。例如锁的 <em>粒度</em> 经常用于确保线程在尽可能短的时间内独占。</p>
<p>此外，使用锁时一个常用优化方法是使用 <em>读写锁</em> ，本文即探讨读写锁的原理并给出相关实现。所有的代码都可以通过 <a href="https://github.com/eliben/code-for-blog/tree/master/2019/rwlocks" target="_blank" rel="external">on GitHub</a>访问。同时，文章的结尾给出了性能测试相关的方法。</p>
<p>本文的撰写目的是为了研究探讨读写锁，如果需要在代码中使用读写锁，Go语言本身已经内置了一个高性能的读写锁：<code>sync.RWMutex</code>。实际上，本文也将探索它的实现。</p>
<p><img src="https://eli.thegreenplace.net/images/2019/rwlock.png" alt=""></p>
<h2 id="读写锁产生的动因"><a href="#读写锁产生的动因" class="headerlink" title="读写锁产生的动因"></a>读写锁产生的动因</h2><p>读写锁产生的动因是为了在无线程写数据的情况下，多个线程能够并发地共享该数据。普通锁并不会区分读线程或者写线程，因此当多个线程需要读取数据时，每个线程都必须先要对该数据上锁，浪费了大量资源。</p>
<p>读写锁相对于普通锁的单个 <em>lock</em> 方法，它有两个方法，一个用于读者、一个用于写者。只要写者没有持有锁，多个读者即可共享数据。</p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>下面实现一个简单的读写锁，使用counter记录读者数量。本文接下来的所有读写锁实现都会实现该接口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> RWLocker <span class="keyword">interface</span> &#123;</div><div class="line">    RLock()    <span class="comment">// 读者获取锁</span></div><div class="line">    RUnlock()  <span class="comment">// 读者释放锁</span></div><div class="line">    WLock()    <span class="comment">// 写者获取锁</span></div><div class="line">    WUnlock()  <span class="comment">// 写者释放锁</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应锁的结构为：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ReaderCountRWLock <span class="keyword">struct</span> &#123;</div><div class="line">    m           sync.Mutex</div><div class="line">    readerCount <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>counter用于记录持有锁的读者数量，读者获取锁、释放锁的逻辑比较简单：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountRWLock)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.m.Lock()</div><div class="line">    l.readerCount++</div><div class="line">    l.m.Unlock()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountRWLock)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.m.Lock()</div><div class="line">    l.readerCount--</div><div class="line">    l.m.Unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>写者获取锁与释放锁的实现则复杂一些，写者在获取锁时必须等待持有锁的读者全部释放锁，代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountRWLock)</span> <span class="title">WLock</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        l.m.Lock()</div><div class="line">        <span class="keyword">if</span> l.readerCount &gt; <span class="number">0</span> &#123;</div><div class="line">            l.m.Unlock()</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">break</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>写者对mutex上锁，同时检查是否存在读者持有锁，如果存在，写者释放mutexx并再次尝试，这也叫 <em>自旋</em> 。如果没有持有锁的读者，WLock将会结束，同时不释放锁，从而读者将无法再持有锁，写者释放锁的逻辑则比较直观：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountRWLock)</span> <span class="title">WUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.m.Unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样的实现方法是我目前能够想到的最简单的方法，它的性能有待优化，例如：当读者持有锁时，写者获取锁的实现会持续自旋，不断的获取锁与释放锁这一过程对CPU的计算能力来说是一种额外的消耗。如果我们能够使写者更高效地等待，那读写锁的性能也将获得提升。</p>
<h2 id="使用条件变量实现高效等待"><a href="#使用条件变量实现高效等待" class="headerlink" title="使用条件变量实现高效等待"></a>使用条件变量实现高效等待</h2><p>条件变量的模式是“获取mutex，检查，如果未准备好则释放mutex”，而这正是我们需要的。因此改进后的读写锁实现是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ReaderCountCondRWLock <span class="keyword">struct</span> &#123;</div><div class="line">    readerCount <span class="keyword">int</span></div><div class="line">    c           *sync.Cond</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你在好奇读写锁中的mutex在哪里，不用担心，Go中，<code>sync.Cond</code> 内嵌一个mutex，这个结构体需要一个构造函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderCountCondRWLock</span><span class="params">()</span> *<span class="title">ReaderCountCondRWLock</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> &amp;ReaderCountCondRWLock&#123;<span class="number">0</span>, sync.NewCond(<span class="built_in">new</span>(sync.Mutex))&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是读者获取锁、释放锁的相关实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountCondRWLock)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.L.Lock()</div><div class="line">    l.readerCount++</div><div class="line">    l.c.L.Unlock()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountCondRWLock)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.L.Lock()</div><div class="line">    l.readerCount--</div><div class="line">    <span class="keyword">if</span> l.readerCount == <span class="number">0</span> &#123;</div><div class="line">        l.c.Signal()</div><div class="line">    &#125;</div><div class="line">    l.c.L.Unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与上一版读写锁实现的区别仅在于这里在最后一个读者释放锁的时候会在条件变量上发出信号。写者获取锁的实现方式为：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountCondRWLock)</span> <span class="title">WLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.L.Lock()</div><div class="line">    <span class="keyword">for</span> l.readerCount &gt; <span class="number">0</span> &#123;</div><div class="line">        l.c.Wait()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的Wait过程仍然处于循环中，因为极有可能在读者发出信号之后、写者获取锁之前，另一个读者先拿到锁。</p>
<p>写者释放锁的过程：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ReaderCountCondRWLock)</span> <span class="title">WUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.Signal()</div><div class="line">    l.c.L.Unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你能理解Signal为什么是需要的吗？缺少它，在特定情况下将会导致死锁：如果两个写者都在等待条件变量，在其中一个获取锁后，另一个将会继续等待，在缺少后续读者发送信号的情况下，这个写者将会永久等待，因此有必要在写着释放锁的时候发出信号。</p>
<p>这一实现比上一版的视线更为高效，因为避免了自旋的过程，尽管这里仍然又一个循环，但它会在Wait执行时阻塞，仅当竞争时才会再次执行循环。</p>
<p>需要注意的是，这里提到的“更高效”并没有相应的数据支撑，因为对上述代码执行性能测试过于复杂，且性能会随着测试样例的变化而变化。后文将会针对性能测试给出说明。</p>
<h2 id="Counted-信号量"><a href="#Counted-信号量" class="headerlink" title="Counted 信号量"></a>Counted 信号量</h2><p>另一种实现读写锁的优雅方式时通过 <em>counting 信号量</em> 实现。在Go中，<code>golang.org/x/sync/semaphore</code>包提供了相关的实现。构造方法与读者获取锁、释放锁的实现如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> maxWeight <span class="keyword">int64</span> = <span class="number">1</span> &lt;&lt; <span class="number">30</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> SemaRWLock <span class="keyword">struct</span> &#123;</div><div class="line">    s *semaphore.Weighted</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// NewSemaRWLock creates a new SemaRWLock.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSemaRWLock</span><span class="params">()</span> *<span class="title">SemaRWLock</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> &amp;SemaRWLock&#123;semaphore.NewWeighted(maxWeight)&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *SemaRWLock)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.s.Acquire(context.Background(), <span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *SemaRWLock)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.s.Release(<span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>写者仅仅是获取整个maxWeight, 从而保证仅有一个写锁能够获取信号量。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *SemaRWLock)</span> <span class="title">WLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.s.Acquire(context.Background(), maxWeight)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *SemaRWLock)</span> <span class="title">WUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.s.Release(maxWeight)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种实现方式非常简洁，在实际测试时，可能是因为 semaphore.Weighted 不适合特定的测试样例，这个方法的性能甚至还没有第一版实现的性能好。</p>
<h2 id="读者优先-vs-写者优先"><a href="#读者优先-vs-写者优先" class="headerlink" title="读者优先 vs. 写者优先"></a>读者优先 vs. 写者优先</h2><p>上述的三种实现都存在一个问题：当读者数量很大时，可能会导致写者饥饿。例如，第一版实现中 readerCount 为0时，写者才能够获取锁，假设有两个活跃的读者以及一个等待的写者，在写者等待一个读者释放锁的过程中，另一个读者可能又会获取锁</p>
<p>这也被叫做 <em>读者优先</em>, 或者 <em>写者饥饿</em> 。下面我们将实现写者优先的相关逻辑。</p>
<h2 id="简单的写者优先读写锁"><a href="#简单的写者优先读写锁" class="headerlink" title="简单的写者优先读写锁"></a>简单的写者优先读写锁</h2><p>实现源于 <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock" target="_blank" rel="external">Wikipedia</a>。首先，数据结构与构造函数如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> WritePreferRWLock <span class="keyword">struct</span> &#123;</div><div class="line">    readerCount <span class="keyword">int</span></div><div class="line">    hasWriter   <span class="keyword">bool</span></div><div class="line">    c           *sync.Cond</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWritePreferRWLock</span><span class="params">()</span> *<span class="title">WritePreferRWLock</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> &amp;WritePreferRWLock&#123;<span class="number">0</span>, <span class="literal">false</span>, sync.NewCond(<span class="built_in">new</span>(sync.Mutex))&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 readerCount 仍然指代持有锁的读者数量, 但我们添加了一个新的字段 - hasWriter; 当有写者等待获取锁的时候，它的值为true。读者获取锁与释放锁的逻辑如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferRWLock)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.L.Lock()</div><div class="line">    <span class="keyword">for</span> l.hasWriter &#123;</div><div class="line">        l.c.Wait()</div><div class="line">    &#125;</div><div class="line">    l.readerCount++</div><div class="line">    l.c.L.Unlock()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferRWLock)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.L.Lock()</div><div class="line">    l.readerCount--</div><div class="line">    <span class="keyword">if</span> l.readerCount == <span class="number">0</span> &#123;</div><div class="line">        l.c.Signal()</div><div class="line">    &#125;</div><div class="line">    l.c.L.Unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当读者尝试获取锁时，会首先检查是否有写者等待获取锁，如果有的话将会让出获取锁的权限，保证写者先获取锁。</p>
<p>在缩放锁的时候，最后一个读者会发出信号，触发在等待的线程执行。</p>
<p>写者获取锁、释放锁的相关实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferRWLock)</span> <span class="title">WLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.L.Lock()</div><div class="line">    <span class="keyword">for</span> l.hasWriter &#123;</div><div class="line">        l.c.Wait()</div><div class="line">    &#125;</div><div class="line">    l.hasWriter = <span class="literal">true</span></div><div class="line">    <span class="keyword">for</span> l.readerCount &gt; <span class="number">0</span> &#123;</div><div class="line">        l.c.Wait()</div><div class="line">    &#125;</div><div class="line">    l.c.L.Unlock()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferRWLock)</span> <span class="title">WUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.c.L.Lock()</div><div class="line">    l.hasWriter = <span class="literal">false</span></div><div class="line">    l.c.Broadcast()</div><div class="line">    l.c.L.Unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>写者将会首先检查是否有其他写者在等待，不同于之前的实现，这里写者在WLock与WUnlock之间不再持有mutex，取而代之，mutex仅用于控制共享结构的访问，hasWriter 字段不仅表示有写者在等待锁，也表示写者正在使用锁，当hashWriter为true时，不再有新的读者能够获取到锁。</p>
<p>在 WUnlock 中, 写者将 hasWriter 置为 false，同时广播信号。这里使用Broadcast而不是Signal是因为可能存在多个读者等待，而我们期望唤醒所有等待的读者。</p>
<h2 id="更高效的写者优先读写锁实现"><a href="#更高效的写者优先读写锁实现" class="headerlink" title="更高效的写者优先读写锁实现"></a>更高效的写者优先读写锁实现</h2><p>上述的实现都比较简洁，但性能表现却不够好。因此，这里我们研究下Go自身读写锁的实现。</p>
<p>实现的总体目标是使读者能够尽快获取锁，同时要保证写优先。</p>
<p>首先是结构体与构造方法的实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> WritePreferFastRWLock <span class="keyword">struct</span> &#123;</div><div class="line">    w sync.Mutex</div><div class="line">    writerWait <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">    readerWait <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">    numPending <span class="keyword">int32</span>         <span class="comment">// 尝试持有锁或已经持有锁的读者数量 </span></div><div class="line">    readersDeparting <span class="keyword">int32</span>   <span class="comment">// 在写者持有锁之前获取锁的读者数量（读者释放锁，也会随之减1）</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> maxReaders <span class="keyword">int32</span> = <span class="number">1</span> &lt;&lt; <span class="number">30</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWritePreferFastRWLock</span><span class="params">()</span> *<span class="title">WritePreferFastRWLock</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> l WritePreferFastRWLock</div><div class="line">    l.writerWait = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</div><div class="line">    l.readerWait = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</div><div class="line">    <span class="keyword">return</span> &amp;l</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mutex w不会被读者所使用，它存在的作用是为写者提供互斥，稍后再介绍它的具体用法。numPending用于表示有多少个读者持有锁（类似上文中的readerCount），但它同时也被写者使用。写者将该字段减去maxReaders，如果得到一个负数就表明一个写者正在使用锁，通过原子操作访问该字段，因此不再需要锁。<br>下面介绍读者相关方法的实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferFastRWLock)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;l.numPending, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</div><div class="line">        &lt;-l.readerWait</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferFastRWLock)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> r := atomic.AddInt32(&amp;l.numPending, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">if</span> atomic.AddInt32(&amp;l.readersDeparting, <span class="number">-1</span>) == <span class="number">0</span> &#123;</div><div class="line">            l.writerWait &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读者获取锁时会对numPending加1，如果numPending是非负数，表明没有写者等待持有锁或正持有锁，因此读者可以继续操作。读者获取锁的方法执行极其频繁，而这里只是用了一个原子操作、一个条件判断，因此速度极快。</p>
<p>如果numPending是负数，表明写者正在等待获取锁或已经获取锁，因此读者将会让出权限，保持等待，这个操作是通过在一个无缓冲channel上等待实现的。</p>
<p>当读者释放锁时，它将numPending减1，如果没有写者等待，执行结束；如果有写者等待，readersDeparting字段用于告知写者一个读者已经释放锁。</p>
<p>写者获取锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferFastRWLock)</span> <span class="title">WLock</span><span class="params">()</span></span> &#123;</div><div class="line">    l.w.Lock()</div><div class="line">    r := atomic.AddInt32(&amp;l.numPending, -maxReaders) + maxReaders</div><div class="line">    <span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;l.readersDeparting, r) != <span class="number">0</span> &#123;</div><div class="line">        &lt;-l.writerWait</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>w mutex用于保证仅有一个写者在任意时间内获取锁。第二行复杂一些，它完成两件事：</p>
<ol>
<li><p>通过执行numPending减maxReaders告知读者存在一个写者等待</p>
</li>
<li><p>通过执行加maxReaders操作，获取有多少个尝试持有锁或持有锁的读者</p>
</li>
</ol>
<p>接下来，如果有任意数量尝试持有锁或持有锁的读者(r != 0)，它将对应数值加入readersDeparting中，——这让读者在解除写者等待前知道有多少个尝试持有锁或持有锁的读者，当最后一个持有锁的读者释放时，函数将返回（写者持有锁），其他写者因为w而陷入等待，而读者则等待numPending变为非负数才能获取锁。</p>
<p>写者释放锁：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *WritePreferFastRWLock)</span> <span class="title">WUnlock</span><span class="params">()</span></span> &#123;</div><div class="line">    r := atomic.AddInt32(&amp;l.numPending, maxReaders)</div><div class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</div><div class="line">        l.readerWait &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line">    &#125;</div><div class="line">    l.w.Unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再一次，通过加maxReaders，写者能够告诉未来的读者已经没有写者还处于等待获取锁的过程中了。r表示等待获取锁的读者数量，写者通过发送r个空对象到readerWait中唤醒所有等待的读者，最后对w解锁，给予后续写者上锁的机会。</p>
<p>这里主要是readersDeparting不太好理解，为了更好的理解它，假设有如下操作：</p>
<ol>
<li>两个读者获取锁（numPending = 2，readersDeparting = 0）</li>
<li>一个写者获取锁(numPending = 2 - MAX, readersDeparting = 2)</li>
<li>一个读者获取锁（numPending = 3 - MAX, readersDeparting = 2）</li>
</ol>
<p>可见，readersDeparting主要用于记录写者上锁前就已经持有锁的读者数量，后续这些这些读者释放锁时，readersDeparting也会随之减少，当它变为0时，恰好说明写者之前获取锁的所有读者均已经释放锁。</p>
<h2 id="后续-性能测试方法"><a href="#后续-性能测试方法" class="headerlink" title="后续: 性能测试方法"></a>后续: 性能测试方法</h2><p>性能测试相关方法的代码位于<a href="https://github.com/eliben/code-for-blog/blob/master/2019/rwlocks/rwlock_test.go" target="_blank" rel="external">GitHub</a>。它的目的是测试正确性，因此它检查多个读者与写者执行的正确性。在执行性能测试时，会记录每个读者与写者获取锁的等待时间，最后打印平均时间。</p>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://eli.thegreenplace.net/2019/implementing-reader-writer-locks/" target="_blank" rel="external">Implementing reader-writer locks</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当处理并发时，锁是最常用的编程语言工具，对于大多数应用而言，仅在使用数据时加锁，使用后释放即可。然而，对于一些对性能要求比较高的并发实现，锁的使用方式需要作出对应的优化。例如锁的 &lt;em&gt;粒度&lt;/em&gt; 经常用于确保线程在尽可能短的时间内独占。&lt;/p&gt;
&lt;p&gt;此外，使用锁时
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="Go 读写锁" scheme="http://blog.yinwoods.work/tags/Go-%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Java中的变型</title>
    <link href="http://blog.yinwoods.work/2019/04/28/Java%E4%B8%AD%E7%9A%84%E5%8F%98%E5%9E%8B/"/>
    <id>http://blog.yinwoods.work/2019/04/28/Java中的变型/</id>
    <published>2019-04-28T03:48:00.000Z</published>
    <updated>2019-05-19T05:17:38.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是变型"><a href="#什么是变型" class="headerlink" title="什么是变型?"></a>什么是变型?</h2><p>维基百科上<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98" target="_blank" rel="external">变型</a>的定义:</p>
<blockquote>
<p><strong>变型</strong>是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。</p>
</blockquote>
<p>许多<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E8%AA%9E%E8%A8%80" title="程序设计语言" target="_blank" rel="external">程序设计语言</a>的<a href="https://zh.wikipedia.org/wiki/%E5%9E%8B%E5%88%A5%E7%B3%BB%E7%B5%B1" title="类型系统" target="_blank" rel="external">类型系统</a>支持<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E5%9E%8B%E5%88%A5" title="子类型" target="_blank" rel="external">子类型</a>。例如，如果<code>Cat</code>是<code>Animal</code>的子类型，那么<code>Cat</code>类型的表达式可用于任何出现<code>Animal</code>类型表达式的地方。所谓的<strong>变型</strong>（variance）是指如何根据组成类型之间的子类型关系，来确定更复杂的类型之间（例如<code>Cat</code>列表之于<code>Animal</code>列表，返回值为<code>Cat</code>的函数之于返回值为<code>Animal</code>的函数…等等）的子类型关系。当我们用类型构造出更复杂的类型，原本类型的子类型性质可能被保持、反转、或忽略───取决于<a href="https://zh.wikipedia.org/wiki/%E5%9E%8B%E5%88%A5%E6%A7%8B%E9%80%A0%E5%99%A8" title="类型构造器" target="_blank" rel="external">类型构造器</a>的变型性质。例如在<a href="https://zh.wikipedia.org/wiki/C%E2%99%AF" title="C♯" target="_blank" rel="external">C#</a>中：</p>
<ul>
<li><p><code>IEnumerable&lt;Cat&gt;</code>是<code>IEnumerable&lt;Animal&gt;</code>的子类型，因为类型构造器<code>IEnumerable&lt;T&gt;</code>是协变的（covariant）。注意到复杂类型<code>IEnumerable</code>的子类型关系和其接口中的参数类型是一致的，亦即，参数类型之间的子类型关系被保持住了。</p>
</li>
<li><p><code>Action&lt;Cat&gt;</code>是<code>Action&lt;Animal&gt;</code>的超类型，因为类型构造器<code>Action&lt;T&gt;</code>是逆变的（contravariant）。（在此，<code>Action&lt;T&gt;</code>被用来表示一个参数类型为<code>T</code>或<code>sub-T</code>的<a href="https://zh.wikipedia.org/wiki/%E4%B8%80%E7%B4%9A%E5%87%BD%E6%95%B8" title="一级函数" target="_blank" rel="external">一级函数</a>）。注意到<code>T</code>的子类型关系在复杂类型<code>Action</code>的封装下是反转的，但是当它被视为函数的参数时其子类型关系是被保持的。</p>
</li>
<li><p><code>IList&lt;Cat&gt;</code>或<code>IList&lt;Animal&gt;</code>彼此之间没有子类型关系。因为<code>IList&lt;T&gt;</code>类型构造器是不变的（invariant），所以参数类型之间的子类型关系被忽略了。</p>
</li>
</ul>
<p>“复杂型别” 指的是如容器、函数之类的高级数据结构，因此变型描述的是通过继承关联的容器、函数的赋值兼容性。例如，我们能够将一个返回值为cat列表的方法返回值赋值到animal列表吗？我们能够将Audi列表作为接收cars列表方法的参数吗？</p>
<h2 id="四种变型"><a href="#四种变型" class="headerlink" title="四种变型"></a>四种变型</h2><p>在一门程序设计语言的<a href="https://zh.wikipedia.org/wiki/%E5%9E%8B%E5%88%A5%E7%B3%BB%E7%B5%B1" title="类型系统" target="_blank" rel="external">类型系统</a>中，一个类型规则或者类型构造器是：</p>
<ul>
<li><strong>协变</strong>（covariant），如果它保持了<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E5%9E%8B%E5%88%A5" title="子类型" target="_blank" rel="external">子类型序关系≦</a>。该序关系是：子类型≦基类型。</li>
<li><strong>逆变</strong>（contravariant），如果它逆转了子类型序关系。</li>
<li><strong>不变</strong>（invariant），如果上述两种均不适用。</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>首先考虑数组类型构造器： 从<code>Animal</code>类型，可以得到<code>Animal[]</code>（“animal数组”）。 是否可以把它当作</p>
<ul>
<li>协变：一个<code>Cat[]</code>也是一个<code>Animal[]</code></li>
<li>逆变：一个<code>Animal[]</code>也是一个<code>Cat[]</code></li>
<li>以上二者均不是（不变）？</li>
</ul>
<p>如果要避免类型错误，且数组支持对其元素的读、写操作，那么只有第3个选择是安全的。<code>Animal[]</code>并不是总能当作<code>Cat[]</code>，因为当一个客户读取数组并期望得到一个<code>Cat</code>，但<code>Animal[]</code>中包含的可能是个<code>Dog</code>。所以逆变规则是不安全的。</p>
<p>反之，一个<code>Cat[]</code>也不能被当作一个<code>Animal[]</code>。因为总是可以把一个<code>Dog</code>放到<code>Animal[]</code>中。在协变数组，这就不能保证是安全的，因为背后的存储可以实际是<code>Cat[]</code>。因此协变规则也不是安全的—数组构造器应该是<strong>不变</strong>。注意，这仅是可写（mutable）数组的问题；对于不可写（只读）数组，协变规则是安全的。</p>
<p>这示例了一般现像。只读数据类型是协变的；只写数据类型是逆变的。可读可写类型应是“不变”的。</p>
<p>Java中泛型是不变的，可有时需要实现逆变与协变，怎么办呢？这时，通配符?派上了用场：</p>
<p><code>&lt;? extends&gt;</code>实现了泛型的协变，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;? extends Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div></pre></td></tr></table></figure></p>
<p><code>&lt;? super&gt;</code>实现了泛型的逆变，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;? <span class="keyword">super</span> Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</div></pre></td></tr></table></figure></p>
<p>extends确定了泛型的上界，而super确定了泛型的下界。</p>
<h3 id="Java中的协变"><a href="#Java中的协变" class="headerlink" title="Java中的协变"></a>Java中的协变</h3><blockquote>
<p>如果 <code>B</code> 是 <code>A</code> 的子类型, 那么 <code>GenericType&lt;B&gt;</code> 是 <code>GenericType&lt;? extends A&gt;</code> 的子类型.</p>
</blockquote>
<p>早期版本的Java不包含<a href="https://zh.wikipedia.org/wiki/%E6%B3%9B%E5%9E%8B" title="泛型" target="_blank" rel="external">泛型</a>（generics，即参数化多态）。在这样的设置下，使数组为“不变”将导致许多有用的多态程序被排除。</p>
<p>例如，考虑一个用于重排（shuffle）数组的函数，或者测试两个数组相等的函数，使用<code>Object</code>与<code>equals</code>方法. 函数的实现并不依赖于数组元素的确切类型，因此可以写一个单独的实现而适用于所有的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalArrays</span> <span class="params">(Object[] a1, Object[] a2)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffleArray</span><span class="params">(Object[] a)</span></span>;</div></pre></td></tr></table></figure></p>
<p>然而，如果数组类型被处理为“不变”，那么它仅能用于确切为<code>Object[]</code>类型的数组。对于字符串数组等就不能做重排操作了。</p>
<p>所以，Java把数组类型处理为协变。在Java中，<code>String[]</code>是<code>Object[]</code>的子类型。</p>
<p>如前文所述，协变数组在写入数组的操作时会出问题。Java为此把每个数组对像在创建时附标一个类型。 每当向数组存入一个值，编译器插入一段代码来检查该值的运行时类型是否等于数组的运行时类型。如果不匹配，会抛出一个<code>ArrayStoreException</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a 是单元素的 String 数组</span></div><div class="line">String[] a = <span class="keyword">new</span> String[<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// b 是 Object 的数组</span></div><div class="line">Object[] b = a;</div><div class="line"></div><div class="line"><span class="comment">// 向 b 中赋一个整数。如果 b 确实是 Object 的数组，这是可能的；然而它其实是个 String 的数组，因此会发生 java.lang.ArrayStoreException</span></div><div class="line">b[<span class="number">0</span>] = <span class="number">1</span>;</div></pre></td></tr></table></figure></p>
<p>在上例中，可以从b中安全地读。仅在写入数组时可能会遇到麻烦。</p>
<p>这个方法的缺点是留下了运行时错误的可能，而一个更严格的<a href="https://zh.wikipedia.org/wiki/%E5%9E%8B%E5%88%A5%E7%B3%BB%E7%B5%B1" title="类型系统" target="_blank" rel="external">类型系统</a>本可以在编译时识别出该错误。这个方法还有损性能，因为在运行时要运行额外的类型检查。</p>
<p>Java有了泛型后，有了类型安全的编写这种多态函数。数组比较与重排可以给定参数类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">equalArrays</span> <span class="params">(T[] a1, T[] a2)</span></span>;</div><div class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">shuffleArray</span><span class="params">(T[] a)</span></span>;</div></pre></td></tr></table></figure></p>
<h3 id="协变容器"><a href="#协变容器" class="headerlink" title="协变容器"></a>协变容器</h3><p>Java允许子类型（协变）泛型类型，但它会严格限制可以“流入和流出“的泛型类型。换句话说，具有类型参数的返回值的方法是可访问的，而具有类型参数的输入参数的方法是不可访问的。</p>
<p>您可以为子类型赋值超类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person :&gt; Joe :&gt; JoeJr</span></div><div class="line">List&lt;? extends Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;Joe&gt;(); <span class="comment">// OK，没问题👌</span></div><div class="line">List&lt;? extends Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;JoeJr&gt;(); <span class="comment">// OK，没问题👌</span></div><div class="line">List&lt;? extends Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;Person&gt;(); <span class="comment">// COMPILE ERROR</span></div></pre></td></tr></table></figure>
<p>也可从协变容器中 <em>读出</em> 超类型:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person :&gt; Joe :&gt; JoeJr</span></div><div class="line">List&lt;? extends Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">Joe j = joes.get(<span class="number">0</span>); <span class="comment">// OK，没问题👌</span></div><div class="line">Person p = joes.get(<span class="number">0</span>); <span class="comment">// OK，没问题👌</span></div><div class="line">JoeJr jr = joes.get(<span class="number">0</span>); <span class="comment">// compile error (you don't know what subtype of Joe is in the list)</span></div></pre></td></tr></table></figure></p>
<p>但向协变容器 <em>写入</em> 超类型是禁止的。在下例的代码中, 如果其他方法向 <code>List&lt;? extends Person&gt;</code> 参数中加入 <code>Jill</code>，<code>List&lt;Joe&gt;</code> 的调用房将会 <em>混乱</em> 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person &gt; Joe &gt; JoeJr</span></div><div class="line">List&lt;? extends Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">joes.add(<span class="keyword">new</span> Joe());  <span class="comment">// compile error (无法知道joes接受Joe的什么子类型)</span></div><div class="line">joes.add(<span class="keyword">new</span> JoeJr()); <span class="comment">// compile error (ditto)</span></div><div class="line">joes.add(<span class="keyword">new</span> Person()); <span class="comment">// compile error (intuitive)</span></div><div class="line">joes.add(<span class="keyword">new</span> Object()); <span class="comment">// compile error (intuitive)</span></div></pre></td></tr></table></figure></p>
<h2 id="Java中的不变"><a href="#Java中的不变" class="headerlink" title="Java中的不变"></a>Java中的不变</h2><blockquote>
<p>如果 <code>A</code> 是 <code>B</code> 的超类型, 那么 <code>GenericType&lt;A&gt;</code> <strong>不是</strong> <code>GenericType&lt;B&gt;</code> 的超类型，以及反之亦然。</p>
</blockquote>
<p>也就是说两种类型互不关联，且在任何条件下都不能互换。</p>
<h3 id="不变容器"><a href="#不变容器" class="headerlink" title="不变容器"></a>不变容器</h3><p>在Java中，不变量可能是您将遇到的泛型的第一个例子，并且是最直观的。类型参数的方法可以像人们期望的那样使用。可以访问类型参数的所有方法。</p>
<p>他们无法交换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person :&gt; Joe :&gt; JoeJr</span></div><div class="line">List&lt;Person&gt; p = <span class="keyword">new</span> ArrayList&lt;Joe&gt;(); <span class="comment">// COMPILE ERROR (a bit counterintuitive, but remember List&lt;Person&gt; is invariant)</span></div><div class="line">List&lt;Joe&gt; j = <span class="keyword">new</span> ArrayList&lt;Person&gt;(); <span class="comment">// COMPILE ERROR</span></div></pre></td></tr></table></figure></p>
<p>但可以向容器中添加对应对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person :&gt; Joe :&gt; JoeJr</span></div><div class="line">List&lt;Person&gt; p = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">p.add(<span class="keyword">new</span> Person()); <span class="comment">// OK</span></div><div class="line">p.add(<span class="keyword">new</span> Joe()); <span class="comment">// OK</span></div><div class="line">p.add(<span class="keyword">new</span> JoeJr()); <span class="comment">// OK</span></div></pre></td></tr></table></figure></p>
<p>也可以从容器中读取对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person :&gt; Joe :&gt; JoeJr</span></div><div class="line">List&lt;Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">Joe j = joes.get(<span class="number">0</span>); <span class="comment">// OK</span></div><div class="line">Person p = joes.get(<span class="number">0</span>); <span class="comment">// OK</span></div></pre></td></tr></table></figure></p>
<h2 id="Java中的逆变"><a href="#Java中的逆变" class="headerlink" title="Java中的逆变"></a>Java中的逆变</h2><blockquote>
<p>如果 <code>A</code> 是 <code>B</code> 的超类型, 那么 <code>GenericType&lt;A&gt;</code> 是 <code>GenericType&lt;? super B&gt;</code> 的超类型。</p>
</blockquote>
<h3 id="逆变容器"><a href="#逆变容器" class="headerlink" title="逆变容器"></a>逆变容器</h3><p>逆变容器表现同协变容器相反，也就是说，可以具有类型参数的输入参数的方法是可访问的，而具有类型参数的返回值的方法是不可访问的。</p>
<p>可以为超类型赋值子类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person &gt; Joe &gt; JoeJr</span></div><div class="line">List&lt;? <span class="keyword">super</span> Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;Joe&gt;();  <span class="comment">// OK</span></div><div class="line">List&lt;? <span class="keyword">super</span> Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;Person&gt;(); <span class="comment">// OK</span></div><div class="line">List&lt;? <span class="keyword">super</span> Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;JoeJr&gt;(); <span class="comment">// COMPILE ERROR</span></div></pre></td></tr></table></figure></p>
<p>但不能从容器中读出特定类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person &gt; Joe &gt; JoeJr</span></div><div class="line">List&lt;? <span class="keyword">super</span> Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">Joe j = joes.get(<span class="number">0</span>); <span class="comment">// compile error (0位置的元素可以是Object或Person)</span></div><div class="line">Person p = joes.get(<span class="number">0</span>); <span class="comment">// compile error (ditto)</span></div><div class="line">Object o = joes.get(<span class="number">0</span>); <span class="comment">// 能够执行，因为Java中一切皆对象</span></div></pre></td></tr></table></figure></p>
<p>可以向其添加直接子类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person &gt; Joe &gt; JoeJr</span></div><div class="line">List&lt;? <span class="keyword">super</span> Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">joes.add(<span class="keyword">new</span> JoeJr()); <span class="comment">// allowed</span></div></pre></td></tr></table></figure></p>
<p>但不能向其添加超类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person &gt; Joe &gt; JoeJr</span></div><div class="line">List&lt;? <span class="keyword">super</span> Joe&gt; joes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">joes.add(<span class="keyword">new</span> Person()); <span class="comment">// compile error (again, could be a list of Object or Person or Joe)</span></div><div class="line">joes.add(<span class="keyword">new</span> Object()); <span class="comment">// compile error (ditto)</span></div></pre></td></tr></table></figure></p>
<h2 id="具有-N-Type-参数结构的协变"><a href="#具有-N-Type-参数结构的协变" class="headerlink" title="具有 N-Type 参数结构的协变"></a>具有 N-Type 参数结构的协变</h2><p>对于如Functions这种更复杂的类型，规则同样适用，只是需要考虑多个参数规则:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type hierarchy: Person &gt; Joe &gt; JoeJr</span></div><div class="line"></div><div class="line"><span class="comment">// 不变</span></div><div class="line">Function&lt;Person, Joe&gt; personToJoe = <span class="keyword">null</span>;</div><div class="line">Function&lt;Joe, JoeJr&gt; joeToJoeJr = <span class="keyword">null</span>;</div><div class="line">personToJoe = joeToJoeJr; <span class="comment">// COMPILE ERROR (personToJoe 是不变的)</span></div><div class="line"></div><div class="line"><span class="comment">// 协变</span></div><div class="line">Function&lt;? extends Person, ? extends Joe&gt; personToJoe = <span class="keyword">null</span>; <span class="comment">// 协变</span></div><div class="line">Function&lt;Joe, JoeJr&gt; joeToJoeJr = <span class="keyword">null</span>;</div><div class="line">personToJoe = joeToJoeJr;  <span class="comment">// OK</span></div><div class="line"></div><div class="line"><span class="comment">// 逆变</span></div><div class="line">Function&lt;? <span class="keyword">super</span> Joe, ? <span class="keyword">super</span> JoeJr&gt; joeToJoeJr = <span class="keyword">null</span>; <span class="comment">// 逆变</span></div><div class="line">Function&lt;? <span class="keyword">super</span> Person, ? <span class="keyword">super</span> Joe&gt; personToJoe = <span class="keyword">null</span>;</div><div class="line">joeToJoeJr = personToJoe; <span class="comment">// OK</span></div></pre></td></tr></table></figure></p>
<h2 id="协变与继承"><a href="#协变与继承" class="headerlink" title="协变与继承"></a>协变与继承</h2><p>Java允许使用协变返回类型和异常类型重载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="function">Person <span class="title">get</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Joe</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="function">JoeJr <span class="title">get</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoeImpl</span> <span class="keyword">implements</span> <span class="title">Joe</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> JoeJr <span class="title">get</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 重载</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125; <span class="comment">// 重载</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是尝试使用协变参数重载方法只会导致重写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Person p)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Joe</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Joe j)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoeImpl</span> <span class="keyword">implements</span> <span class="title">Joe</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Person p)</span> </span>&#123;&#125;  <span class="comment">// overloaded</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Joe j)</span> </span>&#123;&#125; <span class="comment">// overloaded</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h2 id="Final-Thoughts"><a href="#Final-Thoughts" class="headerlink" title="Final Thoughts"></a>Final Thoughts</h2><p>协变为J​​ava带来了额外的复杂性。虽然协变的规则很容易理解，但关于类型参数方法的可访问性的规则是违反直觉的。理解它们需要暂停手头的工作，额外思考。</p>
<p>但是，我的日常经验是，细微差别通常不会受到影响：</p>
<ul>
<li>我不记得一个我必须声明逆变的实例，我很少遇到它们（虽然它们确实存在）。</li>
<li>协变论证似乎更常见，但同时它们也更容易推理。</li>
</ul>
<p><strong>总结:</strong> 协变在日常编程中提供了适度的便利，特别是当需要与子类型的兼容性时（这在OOP中经常出现）。使用协变、逆变时主要参考PECS（Producer Extends Consumer Super）原则：</p>
<ul>
<li>频繁往外读取内容的，适合用上界Extends（协变）。</li>
<li>经常往里插入的，适合用下界Super（逆变）。</li>
</ul>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://llorllale.github.io/java-variance/#fn:2" target="_blank" rel="external">java-variance</a><br><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98" target="_blank" rel="external">协变与逆变</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是变型&quot;&gt;&lt;a href=&quot;#什么是变型&quot; class=&quot;headerlink&quot; title=&quot;什么是变型?&quot;&gt;&lt;/a&gt;什么是变型?&lt;/h2&gt;&lt;p&gt;维基百科上&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8D%8F%E5
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="Java 变型" scheme="http://blog.yinwoods.work/tags/Java-%E5%8F%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>k8s基本组件及执行流程</title>
    <link href="http://blog.yinwoods.work/2018/06/03/K8S%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>http://blog.yinwoods.work/2018/06/03/K8S基本组件及执行流程/</id>
    <published>2018-06-03T11:54:00.000Z</published>
    <updated>2018-06-04T12:22:07.417Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是kubernetes"><a href="#什么是kubernetes" class="headerlink" title="什么是kubernetes"></a>什么是kubernetes</h3><p>Kubernetes（简称k8s）是谷歌开源的容器编排管理工具，可以将docker理解为基础设施，而k8s则是用基础设施之上的上层建筑，并能够实现对docker的各种管理。它主要提供以下功能：</p>
<ul>
<li>自动花容器部署和复制</li>
<li>支持容器服务的自动伸缩</li>
<li>将容器组织成组，并提供容器间的负载均衡</li>
<li>方便对容器进行管理，以及对应用程序的管理（如滚动更新等）</li>
</ul>
<p>k8s包含以下几个核心组件：</p>
<h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><p>kubelet是与机器上的pod具体交互的组件，它的主要职责是在物理机上启动相关容器并保证它们的运行。kubelet运行的单元是pod；pod是一组共享资源的容器集合，pod有其独立IP，pod中的容器共享pod目录卷。</p>
<h3 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h3><p>etcd担当k8s中数据库的角色，用于k8s中所有信息的存储与更新。</p>
<h3 id="api-server"><a href="#api-server" class="headerlink" title="api server"></a>api server</h3><p>api server是k8s的核心，所有操作都是通过api server来执行，api server将操作相关信息更新到etcd中去，是系统中唯一与etcd直接交互的k8s组件。</p>
<h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><p>Scheduler负责完成集群中pod的调度，通过预选与优选两阶段调度算法的打分得出pod所应调度的最佳节点</p>
<h3 id="k8s运行pod步骤"><a href="#k8s运行pod步骤" class="headerlink" title="k8s运行pod步骤"></a>k8s运行pod步骤</h3><p>一图胜千言，运行一个pod的时序图如下图所示，任何时候都需要注意一点：只有api server直接与etcd交互，其他组件均通过api server与etcd交互，对于执行一个pod，具体的步骤如下：</p>
<ol>
<li>api server 接收到pod创建请求，将pod相关信息写入etcd</li>
<li>scheduler通过api server检测到etcd中有待调度的pod，通过相关调度算法决定将pod分配到某台物理机X上，并把对应信息通过api server写回etcd</li>
<li>物理机X上的kubelet通过api server监测到有待启动的pod，调用物理机上的docker执行pod内容器并完成相关设置，接着将pod已运行的状态通过api server写回etcd</li>
</ol>
<p><img src="http://7xlh6u.com1.z0.glb.clouddn.com/k8s1.jpg" alt="1"></p>
<p>也可参考下面的漫画</p>
<p><img src="http://7xlh6u.com1.z0.glb.clouddn.com/k8s2.jpg" alt="2"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是kubernetes&quot;&gt;&lt;a href=&quot;#什么是kubernetes&quot; class=&quot;headerlink&quot; title=&quot;什么是kubernetes&quot;&gt;&lt;/a&gt;什么是kubernetes&lt;/h3&gt;&lt;p&gt;Kubernetes（简称k8s）是谷歌开源的容器编
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="k8s" scheme="http://blog.yinwoods.work/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>IO模式和IO多路复用</title>
    <link href="http://blog.yinwoods.work/2018/06/02/IO%E6%A8%A1%E5%BC%8F%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://blog.yinwoods.work/2018/06/02/IO模式和IO多路复用/</id>
    <published>2018-06-02T06:54:00.000Z</published>
    <updated>2018-06-02T12:27:55.452Z</updated>
    
    <content type="html"><![CDATA[<p>现在操作系统都采用虚拟寻址，处理器先产生一个虚拟地址，通过地址翻译成物理地址（内存的地址），再通过总线的传递，最后处理器拿到某个物理地址返回的字节。</p>
<p>对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。</p>
<p>核空间：在liunx中，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。</p>
<p>用户空间: 在liunx中，将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间）。</p>
<p>内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态</p>
<p>用户态：每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）</p>
<p>因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统 内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p>
<ul>
<li><p>进程寻址空间0~4G</p>
</li>
<li><p>进程在用户态只能访问0~3G，只有进入内核态才能访问3G~4G</p>
</li>
<li><p>进程通过系统调用进入内核态</p>
</li>
<li>每个进程虚拟空间的3G~4G部分是相同的</li>
</ul>
<h4 id="进程上下文切换（进程切换）"><a href="#进程上下文切换（进程切换）" class="headerlink" title="进程上下文切换（进程切换）"></a>进程上下文切换（进程切换）</h4><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（也叫调度）。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<ol>
<li><p>保存当前进程A的上下文。 上下文就是内核再次唤醒当前进程时所需要的状态，由一些对象（程序计数器、状态寄存器、用户栈等各种内核数据结构）的值组成。 这些值包括描绘地址空间的页表、包含进程相关信息的进程表、文件表等。</p>
</li>
<li><p>切换页全局目录以安装一个新的地址空间。</p>
</li>
<li><p>恢复进程B的上下文。</p>
</li>
</ol>
<p>可以理解成一个比较耗资源的过程。</p>
<h4 id="直接I-O和缓存I-O"><a href="#直接I-O和缓存I-O" class="headerlink" title="直接I/O和缓存I/O"></a>直接I/O和缓存I/O</h4><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，以write为例，数据会先被拷贝进程缓冲区，在拷贝到操作系统内核的缓冲区中，然后才会写到存储设备中。<br><img src="https://l.ruby-china.org/photo/2018/d410db1c-f699-4122-8c4d-e28a348d31dd.png!large" alt="1.3"></p>
<h2 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h2><p>对于一次IO访问（这回以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的缓冲区，最后交给进程。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<ul>
<li><ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
</ol>
</li>
<li><ol>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
</li>
</ul>
<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案：</p>
<ul>
<li>– 阻塞 I/O（blocking IO）</li>
<li>– 非阻塞 I/O（nonblocking IO）</li>
<li>– I/O 多路复用（ IO multiplexing）</li>
<li>– 信号驱动 I/O（ signal driven IO）</li>
<li>– 异步 I/O（asynchronous IO）</li>
</ul>
<h4 id="block-I-O模型（阻塞I-O）"><a href="#block-I-O模型（阻塞I-O）" class="headerlink" title="block I/O模型（阻塞I/O）"></a>block I/O模型（阻塞I/O）</h4><p>read为例：<br><img src="https://l.ruby-china.org/photo/2018/56b3cedc-cd0e-4d54-a001-28004acc71ad.jpg!large" alt="block IO"></p>
<p>（1）进程发起read，进行recvfrom系统调用；</p>
<p>（2）内核开始第一阶段，准备数据（从磁盘拷贝到缓冲区），进程请求的数据并不是一下就能准备好；准备数据是要消耗时间的；</p>
<p>（3）与此同时，进程阻塞（进程是自己选择阻塞与否），等待数据ing；</p>
<p>（4）直到数据从内核拷贝到了用户空间，内核返回结果，进程解除阻塞。</p>
<p>也就是说，内核准备数据和数据从内核拷贝到进程内存地址这两个过程都是阻塞的。</p>
<h4 id="non-block（非阻塞I-O模型）"><a href="#non-block（非阻塞I-O模型）" class="headerlink" title="non-block（非阻塞I/O模型）"></a>non-block（非阻塞I/O模型）</h4><p>可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><img src="https://l.ruby-china.org/photo/2018/77179aa5-7754-4822-8ab4-903566840175.jpg!large" alt="non-block IO"></p>
<p>（1）当用户进程发出read操作时，如果kernel中的数据还没有准备好；</p>
<p>（2）那么它并不会block用户进程，而是立刻返回一个error，从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果；</p>
<p>（3）用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call；</p>
<p>（4）那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p>所以，nonblocking IO的特点是用户进程在内核准备数据的阶段需要不断的主动询问数据好了没有。</p>
<h4 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h4><p>I/O多路复用实际上就是用select, poll, epoll监听多个io对象，对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听；当io对象有变化（有数据）的时候就通知用户进程。现在先来看下I/O多路复用的流程：<br><img src="https://l.ruby-china.org/photo/2018/6b727e99-b45e-4104-ba1d-1dd2dd281e52.jpg!large" alt="I/O多路复用"><br>（1）当用户进程调用了select，那么整个进程会被block；</p>
<p>（2）而同时，kernel会“监视”所有select负责的socket；</p>
<p>（3）当任何一个socket中的数据准备好了，select就会返回；</p>
<p>（4）这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。 但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用多线程 + 阻塞 IO的web server性能更好，可能延迟还更大。</p>
<p>select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h4 id="信号驱动I-O模型"><a href="#信号驱动I-O模型" class="headerlink" title="信号驱动I/O模型"></a>信号驱动I/O模型</h4><p><img src="https://l.ruby-china.org/photo/2018/c672dd70-c22a-42a6-a798-0c12aa7bf765.png!large" alt="sigio"></p>
<p>我们首先开启套接口的信号驱动I/O功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用立即返回，我们的进程继续工作，也就是说它没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。</p>
<p>无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间，进程不被阻塞。主循环可以继续执行，只要不时等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取。</p>
<h4 id="asynchronous-I-O（异步-I-O）"><a href="#asynchronous-I-O（异步-I-O）" class="headerlink" title="asynchronous I/O（异步 I/O）"></a>asynchronous I/O（异步 I/O）</h4><p>异步I/O（asynchronous I/O）由POSIX规范定义。一般地说，这些函数的工作机制是：告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到我们自己的缓冲区）完成后通知我们。这种模型与信号驱动模型的主要区别在于：信号驱动I/O是由内核通知我们何时启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成。</p>
<p><img src="https://l.ruby-china.org/photo/2018/9ad0c25d-72e9-4a2d-8182-5cea6dc73b28.jpg!large" alt="asyncio"></p>
<p>我们调用aio<em>read函数（POSIX异步I/O函数以aio</em>或lio_开头），给内核传递描述字、缓冲区指针、缓冲区大小（与read相同的三个参数）、文件偏移（与lseek类似），并告诉内核当整个操作完成时如何通知我们。该系统调用立即返回，在等待I/O完成期间，我们的进程不被阻塞。</p>
<p>（1）用户进程发起read操作之后，立刻就可以开始去做其它的事。</p>
<p>（2）而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。</p>
<p>（3）然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<h2 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select/poll/epoll"></a>select/poll/epoll</h2><p>在服务器端，每次通过accept系统调用接收客户端请求，建立连接，接着服务器端会获取代表这个连接的文件描述符（Linux下socket也被视为文件），并处理这个文件描述符上的相关请求。当与服务器端连接的大量客户端同时请求时，服务端需要能够感知到请求的到来并及时处理。一个很简单的思路是使用CPU轮询已建立连接的文件描述符上是否有新的请求到来，类似如下的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> descriptor <span class="keyword">in</span> open_connections:</div><div class="line">    <span class="keyword">if</span> has_new_input(descriptor):</div><div class="line">        process_input(descriptor)</div></pre></td></tr></table></figure></p>
<p>这种方法理论上是可行的，但是当大量连接中只有少量是活跃的连接时，这无疑会浪费很多CPU时间，在Linux下，与其在服务端对这些文件描述符做轮询，不如把文件描述符交给内核，让它负责告诉服务端哪个文件描述符上有新的请求。让Linux处理大量文件描户符的操作其实就是I/O多路复用，I/O多路复用的本质就是用select/poll/epoll，去监听多个socket文件描述符，如果其中的socket文件描述符有变化，只要有变化，服务器进程就知道了。</p>
<p>在任意unix机器上，select和poll都是可用的，epoll则只能够在Linux上使用。select和poll的工作方式如下：</p>
<ol>
<li>将多个文件描述符传递给select/poll</li>
<li>select/poll会在任一文件描述符有新的请求到来时告知服务端进程</li>
</ol>
<p>需要注意的是select和poll的源码几乎是相同的，不同的是select支持的操作不如poll支持的丰富，如在文件描述符有新的请求到来时，select只会返回<code>有新的输入</code>、<code>有新的输出</code>或<code>有新的错误</code>；而poll则支持<code>POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR</code>，select会将poll所支持的多种输出统一转换为一种输出：<code>可写</code></p>
<h4 id="select的缺点"><a href="#select的缺点" class="headerlink" title="select的缺点"></a>select的缺点</h4><ul>
<li>单个进程能够监视的文件描述符数量存在大量限制，通常是1024，可以通过重新编译Linux内核的方式修改数量，另外由于select采用轮询的方式扫描文件描述符，所以文件描述符越多，性能越差</li>
<li>内核/用户空间内存拷贝问题，select需要复制大量的句柄数据结构，会产生较大开销</li>
<li>select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能知晓哪些句柄发生了时间</li>
<li>select触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO，那么之后再次select调用还是会将这些文件描述符通知进程</li>
</ul>
<p>相比于select模型，poll使用链表保存文件描述符，因此没有监视文件描述符数量的限制，同时当文件描述符数量较少时，poll的性能表现也会好于select</p>
<p>nodejs使用epoll模型的原因是：epoll并不是采用轮询方式去监听了，而是当socket有变化时通过回调的方式主动告知用户进程。能够有效提升CPU利用率。</p>
<h4 id="epoll实现机制"><a href="#epoll实现机制" class="headerlink" title="epoll实现机制"></a>epoll实现机制</h4><p>epoll通过在Linux内核中申请一个简易的文件系统，把原先的select/poll调用分成了三个部分：</p>
<ul>
<li>调用epoll_create()建立一个epoll对象</li>
<li>调用epoll_ctl()向epoll对象中体检连接套接字</li>
<li>调用epoll_wait()收集发生事件的连接</li>
</ul>
<p>可以看到epoll比select/poll的优越之处：因为后者每次调用时都要传递你所要监控的所有socket给select/poll系统调用，这意味着需要将用户态的socket列表copy到内核态，如果以万计的句柄会导致每次都要copy几十几百KB的内存到内核态，非常低效。而我们调用epoll_wait时就相当于以往调用select/poll，但是这时却不用传递socket句柄给内核，因为内核已经在epoll_ctl中拿到了要监控的句柄列表。</p>
<p>所以，实际上在你调用epoll_create后，内核就已经在内核态开始准备帮你存储要监控的句柄了，每次调用epoll_ctl只是在往内核的数据结构里塞入新的socket句柄。</p>
<p>性能对比：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># operations  |  poll  |  select   | epoll</span></div><div class="line"><span class="number">10</span>            |  <span class="number">0.61</span>  |  <span class="number">0.73</span>     | <span class="number">0.41</span></div><div class="line"><span class="number">100</span>           |  <span class="number">2.9</span>   |  <span class="number">3.0</span>      | <span class="number">0.42</span></div><div class="line"><span class="number">1000</span>          |  <span class="number">35</span>    |  <span class="number">35</span>       | <span class="number">0.53</span></div><div class="line"><span class="number">10000</span>         |  <span class="number">990</span>   |  <span class="number">930</span>      | <span class="number">0.66</span></div></pre></td></tr></table></figure>
<p><strong> 需要注意的是：epoll并不是在所有的应用场景都会比select和poll高很多。尤其是当活动连接比较多的时候，回调函数被触发得过于频繁的时候，epoll的效率也会受到显著影响！所以，epoll特别适用于连接数量多，但活动连接较少的情况。 </strong></p>
<h3 id="LT（水平触发）和ET（边缘触发）"><a href="#LT（水平触发）和ET（边缘触发）" class="headerlink" title="LT（水平触发）和ET（边缘触发）"></a>LT（水平触发）和ET（边缘触发）</h3><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：</p>
<ul>
<li><p>LT：水平触发，效率会低于ET触发，尤其在大并发，大流量的情况下。但是LT对代码编写要求比较低，不容易出现问题。LT模式服务编写上的表现是：只要有数据没有被获取，内核就不断通知你，因此不用担心事件丢失的情况。当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p>
</li>
<li><p>ET：边缘触发，效率非常高，在并发，大流量的情况下，会比LT少很多epoll的系统调用，因此效率高。但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况。当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://ruby-china.org/topics/35472" target="_blank" rel="external">IO 模式和 IO 多路复用 · Ruby China</a><br><a href="https://idea.popcount.org/2017-01-06-select-is-fundamentally-broken/" target="_blank" rel="external">Select is fundamentally broken —    Idea of the day</a><br><a href="https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll/" target="_blank" rel="external">Async IO on Linux: select, poll, and epoll - Julia Evans</a><br>[高并发网络编程之epoll详解]<a href="http://www.cnblogs.com/wuchanming/p/4349743.html" target="_blank" rel="external">http://www.cnblogs.com/wuchanming/p/4349743.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在操作系统都采用虚拟寻址，处理器先产生一个虚拟地址，通过地址翻译成物理地址（内存的地址），再通过总线的传递，最后处理器拿到某个物理地址返回的字节。&lt;/p&gt;
&lt;p&gt;对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。&lt;/p&gt;
&lt;p&gt;核空间：在liunx
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="Linux 操作系统 服务器编程" scheme="http://blog.yinwoods.work/tags/Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>配置不同局域网ssh互联</title>
    <link href="http://blog.yinwoods.work/2017/12/30/%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%90%8C%E5%B1%80%E5%9F%9F%E7%BD%91ssh%E4%BA%92%E8%81%94/"/>
    <id>http://blog.yinwoods.work/2017/12/30/配置不同局域网ssh互联/</id>
    <published>2017-12-30T06:54:00.000Z</published>
    <updated>2017-12-30T06:54:42.677Z</updated>
    
    <content type="html"><![CDATA[<p>最近新向实验室申请了三台服务器用于做毕业设计，但是因为不常在实验室，所以想到有没有一个好的方法能够做到即使不在实验室的局域网中也能够ssh到实验室的机器。也就是说做到从一个局域网中的A机器ssh至另一个局域网中的B机器。</p>
<p>其实大概想一下，就知道完全是可行的，毕竟A与B都联网了，没道理联网的机器却无法互相通信。但也很容易想到存在的限制，就是我怎么拿到B的唯一ID，以此来与它建立通信呢？一般情况下我们ssh用的是域名或者公网IP（归根结底就是公网IP），由此想到能否利用一台具备公网IP的机器C作为两个局域网AB之间的跳板机呢？</p>
<p>看了下ssh命令，发现是可以的，不需要安装其他软件，仅借助ssh即可实现。</p>
<p>在机器B上执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -fCNR &lt;port1&gt;:localhost:22 username@C</div></pre></td></tr></table></figure>
<p>命令的意思是在C上做端口转发，将C机器的port1端口转发到B机器的22端口（22是sshd的默认端口）</p>
<p>这样一来，我们就能够做到使用A ssh连入C，再执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -p port1 localhost</div></pre></td></tr></table></figure>
<p>即可ssh连入B</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近新向实验室申请了三台服务器用于做毕业设计，但是因为不常在实验室，所以想到有没有一个好的方法能够做到即使不在实验室的局域网中也能够ssh到实验室的机器。也就是说做到从一个局域网中的A机器ssh至另一个局域网中的B机器。&lt;/p&gt;
&lt;p&gt;其实大概想一下，就知道完全是可行的，毕
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="ssh 端口转发" scheme="http://blog.yinwoods.work/tags/ssh-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>AWS上kafka端口开放外网访问问题解决方法</title>
    <link href="http://blog.yinwoods.work/2017/11/15/AWS%E4%B8%8AKafka%E7%AB%AF%E5%8F%A3%E5%A4%96%E7%BD%91%E5%BC%80%E6%94%BE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.yinwoods.work/2017/11/15/AWS上Kafka端口外网开放问题解决方法/</id>
    <published>2017-11-15T14:23:00.000Z</published>
    <updated>2017-11-16T07:45:10.954Z</updated>
    
    <content type="html"><![CDATA[<p>目前公司采用ELK来存放以及利用日志，采用filebeat将日志发送至Kafka，之后再写一个python脚本作为消费者把Kafka内的日志拉取下来并打入到elasticsearch中，供后期查询检索使用。</p>
<p>本来这是一套比较完备的流程，但由于最近接了新的业务，而新产生的日志在对方的机器上，也就是说我们需要把Kafka端口开放至公网，供外部机器写入消息；</p>
<p>在确认Kafka端口开放后，远程主机可以连接Kafka并建立topic，但是却无法写日志；中间折腾了好几个小时才折腾出来，觉得有必要记录一下，避免后人踩坑。</p>
<p>首先分别修改kafka集群内机器配置文件如下：</p>
<p> config/server.properties:</p>
<ul>
<li><code>advertised.host=PUBLIC_IP</code></li>
<li><code>host.name=HOST_NAME</code></li>
<li>host.port=9092</li>
</ul>
<p>config/producer.properties:</p>
<ul>
<li><code>metadata.broker.list=PUBLIC_IP</code></li>
</ul>
<p>这样设置之后，远程主机仍然无法写数据，这是因为远程主机无法直接连接<code>HOST_NAME</code>；由此想到修改远程主机的<code>/etc/hosts</code>，修改如下：</p>
<p>/etc/hosts:</p>
<ul>
<li><code>PUBLIC_IP1</code> <code>HOST_NAME1</code></li>
<li><code>PUBLIC_IP2</code> <code>HOST_NAME2</code></li>
<li><code>PUBLIC_IP3</code> <code>HOST_NAME3</code></li>
<li>…</li>
<li><code>PUBLIC_IPn</code> <code>HOST_NAMEn</code></li>
</ul>
<p>综上，经过上面的这些配置，现在filebeat就可以向Kafka打日志了～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前公司采用ELK来存放以及利用日志，采用filebeat将日志发送至Kafka，之后再写一个python脚本作为消费者把Kafka内的日志拉取下来并打入到elasticsearch中，供后期查询检索使用。&lt;/p&gt;
&lt;p&gt;本来这是一套比较完备的流程，但由于最近接了新的业务，
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="kafka aws" scheme="http://blog.yinwoods.work/tags/kafka-aws/"/>
    
  </entry>
  
  <entry>
    <title>druid hadoop index 任务性能调优</title>
    <link href="http://blog.yinwoods.work/2017/08/22/druid-hadoop-index%E4%BB%BB%E5%8A%A1%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://blog.yinwoods.work/2017/08/22/druid-hadoop-index任务性能调优/</id>
    <published>2017-08-22T14:23:00.000Z</published>
    <updated>2017-08-22T14:43:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>由于日常所做统计多数基于一份拼接日志，结合最近做的druid相关工作，很自然的想到把拼接日志一些统计常用字段select group by 出来通过 druid统计，这样就可以把自己从枯燥繁琐的统计脚本中解脱出来了。</p>
<h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><p>但是在执行druid的index任务时遇到了任务执行时间过久的问题，由于集群上还有其他例行服务需要资源，因此我这个低优先级的任务必须能够快速执行完成才可以。通过试错以及对网上相关资料的搜索，得到一下几种方法：</p>
<ul>
<li>通过设置yarn的调度策略，为这种默认占用资源多、执行时间久的任务单独开辟一个队列，限制其能够使用的最大资源量，从而保证其他高优先级的任务能够及时得到处理。而hadoop index任务可以通过在tuningConfig中的jobProperties设置mapreduce.job.queuename</li>
<li>降低每个segment的行数，这个可以通过设置targetPartitionSize完成。因为一个segment对应一个reducer，所以通过减少行数，增加segments个数从而增加reducer个数，充分应用并行化。</li>
<li>在ioConfig中设置rowFlushBoundary字段，并尽可能大。这个参数意味着在将数据写入磁盘前堆中缓存的行数，通过提高缓存从而优化任务执行效率。但也要注意设置不要超过堆内存的上限。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p>1、<a href="https://groups.google.com/forum/#!topic/druid-user/hG8ctsdt7XA" target="_blank" rel="external">Scheduling Hadoop indexing tasks in specific YARN queue</a></p>
</li>
<li><p>2、<a href="https://groups.google.com/forum/#!msg/druid-user/w82AsjkHzzk/qIxbjrcVBgAJ" target="_blank" rel="external">Druid hadoop EMR indexing is extremly slow</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;p&gt;由于日常所做统计多数基于一份拼接日志，结合最近做的druid相关工作，很自然的想到把拼接日志一些统计常用字段select group by
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="druid" scheme="http://blog.yinwoods.work/tags/druid/"/>
    
  </entry>
  
  <entry>
    <title>druid内存占用过多问题排查</title>
    <link href="http://blog.yinwoods.work/2017/08/02/druid%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>http://blog.yinwoods.work/2017/08/02/druid内存占用过多问题排查/</id>
    <published>2017-08-02T13:53:00.000Z</published>
    <updated>2017-08-02T14:05:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用druid来做广告平台的实时分析，发现后台内存占用长期为48G（一共56G），起初怀疑是因为每天dataSource数据量较大，如果druid将所有数据加载进内存处理则会导致这么48G的内存占用；但是在对dataSource做reindex处理后，dataSource大小缩减为5M左右的情况下内存仍然没有降下来。</p>
<p>通过对系统状况的综合考虑，现在有以下两个猜想：</p>
<ul>
<li>druid配置错误，即使dataSource很小，druid仍然抢着内存不放</li>
<li>reindex操作错误，之前的segment并未删除，druid仍然加载内存导致内存溢出</li>
</ul>
<p>其实这里之所以对问题产生的原因不确定，很大程度上是因为自己对druid这一套服务并不了解，经过查阅官方文档，了解到druid并不会把所有的数据加载进内存再处理。 而且，在执行reindex时，historical的数据会被删除，但deep storage内的数据仍然保留；在处理后续查询的过程中historical也不会按需重新将deep storage中的数据加载进来。如果确实有查询已删除segment数据的需求，可以先将数据从deep segment导入historical，之后再查询。如果想从deep storage中删除segment可以参考：<a href="http://druid.io/docs/latest/misc/tasks.html" target="_blank" rel="external">🔗</a></p>
<p>historical并不会按需将所有数据存入segmentCache，只有在coordinator要求historical提前载入一个segment时才会把数据存入segmentCache。也就是说historical在加载数据时会先将所有的segment数据下载至本地硬盘，因此要注意在加载数据之前需要保证historical节点有足够的硬盘空间存放这些数据。</p>
<p>对于查询频率不高的历史数据，可以使用以下两个办法来降低成本：</p>
<p>1、在性能相对较差的机器上（比如使用机械硬盘而不是SSD）构建historical节点并设置tier规则来专门处理这些历史数据</p>
<p>2、另一个方法是对超过某个历史时期的数据设置较大的query granularity，从而降低segment大小；</p>
<p>具体的historical tier配置参考<a href="http://druid.io/docs/latest/configuration/historical.html" target="_blank" rel="external">🔗</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用druid来做广告平台的实时分析，发现后台内存占用长期为48G（一共56G），起初怀疑是因为每天dataSource数据量较大，如果druid将所有数据加载进内存处理则会导致这么48G的内存占用；但是在对dataSource做reindex处理后，dataSourc
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="druid" scheme="http://blog.yinwoods.work/tags/druid/"/>
    
  </entry>
  
  <entry>
    <title>airflow + celery 踩坑记录</title>
    <link href="http://blog.yinwoods.work/2017/07/26/airflow+celery%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://blog.yinwoods.work/2017/07/26/airflow+celery踩坑记录/</id>
    <published>2017-07-26T09:02:00.000Z</published>
    <updated>2017-07-26T15:51:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初识-airflow"><a href="#初识-airflow" class="headerlink" title="初识 airflow"></a>初识 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a></h3><p>其实早在去年就已经接触到 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 了，当时的需求是按小时拼接两份线上日志，而拼接操作必须依赖于两份日志的完整性。从这个需求出发，了解到了 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> ，但迫于官方文档的晦涩难懂，再加上这个任务对 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 的需求不够强，就弃坑了；最后使用 python 脚本中一个 while True 死循环 + time.sleep() 来解决问题(如果所依赖的日志没有完全写入，则 sleep 一段时间)。</p>
<h3 id="正式入坑"><a href="#正式入坑" class="headerlink" title="正式入坑"></a>正式入坑</h3><p>前几天 boss 布置了一个广告平台的统计任务，依赖倒也不复杂，但是考虑到未来平台的扩展性，还是需要一个能够很好的处理统计任务的工具的。自己也调研比较了一下<code>ETL(数据仓库)</code>这方面的工具，确实数 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 功能最为强大，既然这样那就入坑吧。</p>
<h3 id="airflow-安装配置过程"><a href="#airflow-安装配置过程" class="headerlink" title="airflow 安装配置过程"></a><a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 安装配置过程</h3><p>这里都是按照官网操作，具体如下:</p>
<p>1、设置 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 项目路径，默认是用户主目录下 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> ，也可以显示用环境变量 <code>AIRFLOW_HOME</code> 指定;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> AIRFLOW_HOME=~/airflow</div></pre></td></tr></table></figure>
<p>2、<a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 安装，因为 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 是基于 python 编写，因此可以直接利用 pip 安装，这里要注意的是 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 还提供了使用其他软件的插件，例如 mysql、hdfs、hive 等工具，当然这些也可以在后续需要时再安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pip3 install airflow</div><div class="line"></div><div class="line"><span class="comment"># 安装 [airflow](https://github.com/apache/incubator-airflow) hive 插件</span></div><div class="line">pip3 install <span class="string">"airflow[hive]"</span></div></pre></td></tr></table></figure>
<p>3、初始化 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 相关数据库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">airflow initdb</div></pre></td></tr></table></figure>
<p>4、启动 webserver 服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">airflow webserver</div></pre></td></tr></table></figure>
<p>至此，一个最基础的 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 服务就启动了，下面说一说 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 的配置。</p>
<h3 id="airflow-基础配置"><a href="#airflow-基础配置" class="headerlink" title="airflow 基础配置"></a><a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 基础配置</h3><p><a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 的配置文件保存在项目目录下，命名为 airflow.cfg ，通过文件内的注释也可以知道每个配置项的大致含义，这里简单说下常用的配置项。</p>
<h4 id="更改数据库"><a href="#更改数据库" class="headerlink" title="更改数据库"></a>更改数据库</h4><p><a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 为了能够让用户快速使用选择了 sqllite 数据库，但在实际使用中，往往 mysql 更为广泛使用，若要使 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 使用 mysql ，首先执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip3 install <span class="string">"airflow[mysql]"</span></div></pre></td></tr></table></figure>
<p>更改 airflow.cfg 中 <code>sql_alchemy_conn</code> 的值，通过变量名可知配置使用的是 <a href="https://www.sqlalchemy.org/" target="_blank" rel="external">sql_alchemy</a> 的数据库连接字符串，具体格式为：<code>mysql+pymysql://username:password@host:port/database</code>，当然这里 <a href="https://github.com/PyMySQL/PyMySQL" target="_blank" rel="external">pymysql</a> 可以根据自己喜好更换。</p>
<p>修改完配置文件后，需要执行 <code>airflow resetdb</code> 并重新启动 web 服务(<code>airflow webserver</code>)，数据库更换则生效。</p>
<h4 id="为web服务开启用户身份验证功能"><a href="#为web服务开启用户身份验证功能" class="headerlink" title="为web服务开启用户身份验证功能"></a>为web服务开启用户身份验证功能</h4><p><a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 默认是无需登录即可访问使用的，而在实际生产环境中为了提高系统的安全性，需要开启用户身份验证功能，具体步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[webserver]</div><div class="line"><span class="comment"># 开启用户身份验证</span></div><div class="line">authenticate = True</div><div class="line"></div><div class="line"><span class="comment"># 根据用户显示dag列表(依赖于用户身份验证的开启)</span></div><div class="line">filter_by_owner = False</div></pre></td></tr></table></figure>
<p>这样就开启了用户身份验证的功能，但系统还没有默认用户，需要自行手动添加，有两种方式，一种是直接插入默认用户信息到数据库对应的 users 表中(不推荐);另一种则是通过 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 提供的功能来添加，具体操作如下：</p>
<p>打开ipython，执行以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> airflow</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> airflow <span class="keyword">import</span> models, settings</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> airflow.contrib.auth.backends.password_auth <span class="keyword">import</span> PasswordUser</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>user = PasswordUser(models.User())</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>user.username = <span class="string">'new_user_name'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>user.email = <span class="string">'new_user_email@example.com'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>user.password = <span class="string">'set_the_password'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>session = settings.Session()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>session.add(user)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>session.commit()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>session.close()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>exit()</div></pre></td></tr></table></figure>
<p>重启 web 服务( <code>airflow webserver</code> )，刷新网址浏览器会自动跳转到用户登录页面。</p>
<h3 id="配置-airflow-Celery"><a href="#配置-airflow-Celery" class="headerlink" title="配置 airflow + Celery"></a>配置 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> + <a href="http://www.celeryproject.org/" target="_blank" rel="external">Celery</a></h3><p><a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 提供了三种 Executor ，分别是 <code>SequentialExecutor</code>、<code>LocalExecutor</code> 以及 <code>CeleryExecutor</code>；<a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 配置文件中，默认的执行方式是(<code>SequentialExecutor</code>)，这三者的特点如下：</p>
<ul>
<li><code>SequentialExecutor</code>: 单进程顺序执行，通常只用于测试</li>
<li><code>LocalExecutor</code>: 多进程本地执行，使用python的多进程库达到多进程执行目的</li>
<li><code>CeleryExecutor</code>: 使用<a href="http://www.celeryproject.org/" target="_blank" rel="external">Celery</a> 作为执行器，配置 <a href="http://www.celeryproject.org/" target="_blank" rel="external">Celery</a> 后可以利用集群分布式执行任务</li>
</ul>
<p>在这里我选用了<a href="http://www.celeryproject.org/" target="_blank" rel="external">Celery</a>，同样是为了 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 未来的可扩展性。</p>
<p>官方文档中提到使用 <a href="http://www.celeryproject.org/" target="_blank" rel="external">Celery</a> 时，后端服务可以使用 <a href="https://www.rabbitmq.com/" target="_blank" rel="external">RabbitMQ</a> 或 <a href="https://redis.io/" target="_blank" rel="external">Redis</a> ，相对来说自己对 redis 熟悉一些，但据我所知 <a href="https://redis.io/" target="_blank" rel="external">Redis</a> 相对来说比较吃内存，因此在这里选用了 <a href="https://www.rabbitmq.com/" target="_blank" rel="external">RabbitMQ</a> 。具体配置如下：</p>
<h4 id="安装-RabbitMQ"><a href="#安装-RabbitMQ" class="headerlink" title="安装 RabbitMQ"></a>安装 <a href="https://www.rabbitmq.com/" target="_blank" rel="external">RabbitMQ</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Ubuntu 17.04</span></div><div class="line">sudo apt install erlang rabbitmq-server</div></pre></td></tr></table></figure>
<h4 id="RabbitMQ-添加用户并设置密码"><a href="#RabbitMQ-添加用户并设置密码" class="headerlink" title="RabbitMQ 添加用户并设置密码"></a><a href="https://www.rabbitmq.com/" target="_blank" rel="external">RabbitMQ</a> 添加用户并设置密码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Ubuntu 17.04</span></div><div class="line">sudo rabbitmqctl add_user airflow airflow</div><div class="line">sudo rabbitmqctl add_vhost airflow</div><div class="line">sudo rabbitmqctl set_user_tags airflow airflow</div><div class="line">sudo rabbitmqctl set_permissions -p airflow airflow <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></div><div class="line">sudo rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</div></pre></td></tr></table></figure>
<p>更改配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># transport://userid:password@hostname:port/virtual_host</span></div><div class="line">broker_url = amqp://ariflow:airflow@localhost:5672/airflow</div><div class="line">celery_result_backend = amqp://airflow:airflow@localhost:5672/airflow</div></pre></td></tr></table></figure>
<p>至此 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> + <a href="http://www.celeryproject.org/" target="_blank" rel="external">Celery</a> 配置完成，接下来说说如何启动服务</p>
<h3 id="启动-Airflow-Celery-服务"><a href="#启动-Airflow-Celery-服务" class="headerlink" title="启动 Airflow + Celery 服务"></a>启动 Airflow + Celery 服务</h3><p>一共有四个服务，分别是：</p>
<ul>
<li><code>airflow webserver</code> 服务</li>
<li><code>airflow flower</code> <a href="http://www.celeryproject.org/" target="_blank" rel="external">Celery</a> 管理界面</li>
<li><code>airflow worker</code> <a href="http://www.celeryproject.org/" target="_blank" rel="external">Celery</a> Worker</li>
<li><code>airflow scheduler</code> 调度器</li>
</ul>
<h4 id="启动-airflow-webserver-服务"><a href="#启动-airflow-webserver-服务" class="headerlink" title="启动 airflow webserver 服务"></a>启动 <code>airflow webserver</code> 服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">airflow webserver</div></pre></td></tr></table></figure>
<h4 id="启动airflow-flower"><a href="#启动airflow-flower" class="headerlink" title="启动airflow flower"></a>启动<a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> flower</h4><p><code>airflow flower</code> 是一个监控 <a href="http://www.celeryproject.org/" target="_blank" rel="external">Celery</a> 分布式队列的 web 服务，通过它可以看到 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> dag 中task 的执行状况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">airflow flower</div></pre></td></tr></table></figure>
<h4 id="启动-airflow-worker"><a href="#启动-airflow-worker" class="headerlink" title="启动 airflow worker"></a>启动 <code>airflow worker</code></h4><p><a href="http://www.celeryproject.org/" target="_blank" rel="external">Celery</a> 的 worker，用于执行 dag 中具体的 task</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">airflow worker</div></pre></td></tr></table></figure>
<h4 id="启动-airflow-scheduler"><a href="#启动-airflow-scheduler" class="headerlink" title="启动 airflow scheduler"></a>启动 <code>airflow scheduler</code></h4><p><code>airflow scheduler</code> 用于启动调度器，完成对 dag 中 task 的调度。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">airflow scheduler</div></pre></td></tr></table></figure>
<h3 id="airflow-简单示例"><a href="#airflow-简单示例" class="headerlink" title="airflow 简单示例"></a><a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 简单示例</h3><p>环境已经搭好，现在写个 dag 来测试一下 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 吧。在具体的代码展现之前，先介绍一下上文已经出现多次的 dag 这个概念，dag 对于熟悉图论的同学一定不陌生，也即 <code>(Directed Acyclic Graph, DAG)</code> ，为什么叫有向无环图呢，因为任务之间的依赖关系就是一个 DAG ，如下图：<br><img src="/images/dag.png" alt="DAG">。</p>
<p><a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 会默认读取 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 目录下 dags 中的所有 python 文件作为 dag ，因此我们新建一个 dags 目录，并将下面的代码写入 <code>dags/test.py</code> 中，为了能够方便看到 dag 测试成功与否，在 test.py 里面设置了每次向 test 目录下的文件写入新内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> builtins <span class="keyword">import</span> range</div><div class="line"><span class="keyword">import</span> airflow</div><div class="line"><span class="keyword">from</span> airflow.operators.python_operator <span class="keyword">import</span> PythonOperator</div><div class="line"><span class="keyword">from</span> airflow.models <span class="keyword">import</span> DAG</div><div class="line"></div><div class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</div><div class="line"></div><div class="line">args = &#123;</div><div class="line">    <span class="string">'owner'</span>: <span class="string">'yinwoods'</span>,</div><div class="line">    <span class="string">'start_date'</span>: airflow.utils.dates.datetime(<span class="number">2017</span>, <span class="number">7</span>, <span class="number">27</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">dag = DAG(</div><div class="line">    dag_id=<span class="string">'yinwoods'</span>, default_args=args,</div><div class="line">    schedule_interval=<span class="string">'0 1 * * *'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_write_function</span><span class="params">(random_base)</span>:</span></div><div class="line">    <span class="string">"""This is a function that will run within the DAG execution"""</span></div><div class="line">    <span class="keyword">with</span> open(<span class="string">'~/airflow/test/'</span> + random_base, <span class="string">'a'</span>) <span class="keyword">as</span> f:</div><div class="line">        f.write(random_base[<span class="number">-1</span>] + <span class="string">'\n'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_context</span><span class="params">(ds, **kwargs)</span>:</span></div><div class="line">    pprint(kwargs)</div><div class="line">    print(ds)</div><div class="line">    <span class="keyword">return</span> <span class="string">'Whatever you return gets printed in the logs'</span></div><div class="line"></div><div class="line"></div><div class="line">run_this = PythonOperator(</div><div class="line">    task_id=<span class="string">'print_the_context'</span>,</div><div class="line">    provide_context=<span class="keyword">True</span>,</div><div class="line">    python_callable=print_context,</div><div class="line">    op_kwargs=&#123;<span class="string">'test'</span>: <span class="string">'test'</span>&#125;,</div><div class="line">    dag=dag)</div><div class="line"></div><div class="line"><span class="comment"># Generate 10 sleeping tasks, sleeping from 0 to 9 seconds respectively</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    task = PythonOperator(</div><div class="line">        task_id=<span class="string">'print_for_'</span> + str(i),</div><div class="line">        python_callable=my_write_function,</div><div class="line">        op_kwargs=&#123;<span class="string">'random_base'</span>: <span class="string">'file_'</span> + str(i)&#125;,</div><div class="line">        dag=dag)</div><div class="line"></div><div class="line">    task.set_upstream(run_this)</div></pre></td></tr></table></figure>
<p>以上代码保存后，执行 <code>python test.py</code> 即将该 dag 导入 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 中，之后可以选用 <code>airflow test</code> 或 <code>airflow backfill</code> 测试，这里就不再讲述具体用法。</p>
<p>启动 dag 时既可以使用 <code>airflow run dag_id task_id execution_date</code> ，也可以使用 web 界面的执行按钮执行。但需要注意的是，在启动之前需要 <code>airflow unpause dag_id</code> 或在 web 界面开启 dag 对应的按钮。</p>
<p>接下来就可以看到执行状态以及结果了。另外下面提供了另一份示例代码，注意观察这份代码中定义任务间依赖关系的语句:)，个人认为这样的语句能够更直观表明任务之间的关系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="keyword">from</span> [airflow](https://github.com/apache/incubator-airflow) <span class="keyword">import</span> DAG</div><div class="line"><span class="keyword">from</span> airflow.operators.dummy_operator <span class="keyword">import</span> DummyOperator</div><div class="line"><span class="keyword">from</span> airflow.operators.python_operator <span class="keyword">import</span> PythonOperator</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello world!'</span></div><div class="line"></div><div class="line">dag = DAG(<span class="string">'hello_world'</span>, description=<span class="string">'Simple tutorial DAG'</span>,</div><div class="line">          schedule_interval=<span class="string">'0 12 * * *'</span>,</div><div class="line">          start_date=datetime(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">20</span>),</div><div class="line">          catchup=<span class="keyword">False</span>)</div><div class="line"></div><div class="line">dummy_operator = DummyOperator(task_id=<span class="string">'dummy_task'</span>, retries=<span class="number">3</span>, dag=dag)</div><div class="line"></div><div class="line">hello_operator = PythonOperator(task_id=<span class="string">'hello_task'</span>,</div><div class="line">                                python_callable=print_hello, dag=dag)</div><div class="line"></div><div class="line">dummy_operator &gt;&gt; hello_operator</div></pre></td></tr></table></figure>
<p>如果执行 dag 后，发现 dag 中部分 task 一直处于 queue 的状态，可以查看 <code>airflow scheduler</code> 的执行状态，如果是挂掉了，且重启后又挂掉可以参考下面的解决方法。</p>
<h3 id="改源码解决-airflow-scheduler-中断-bug"><a href="#改源码解决-airflow-scheduler-中断-bug" class="headerlink" title="改源码解决 airflow scheduler 中断 bug"></a>改源码解决 <code>airflow scheduler</code> 中断 bug</h3><p>我在使用 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a>  的过程中，产生了 <code>airflow scheduler</code> 启动后执行片刻即被断开连接的情况，通过谷歌搜索，找到了以下修改 <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 源码的解决方法，至于这个中断bug的具体原因尚不清楚。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">--- /usr/local/lib/python3<span class="number">.4</span>/dist-packages/airflow/jobs.py.orig	<span class="number">2017</span><span class="number">-02</span><span class="number">-16</span> <span class="number">11</span>:<span class="number">58</span>:<span class="number">55.057991344</span> +<span class="number">0000</span></div><div class="line">+++ /usr/local/lib/python3<span class="number">.4</span>/dist-packages/airflow/jobs.py	<span class="number">2017</span><span class="number">-02</span><span class="number">-16</span> <span class="number">11</span>:<span class="number">57</span>:<span class="number">07.060060262</span> +<span class="number">0000</span></div><div class="line"><span class="meta">@@ -1371,6 +1371,8 @@</span></div><div class="line">         last_stat_print_time = datetime(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">         <span class="comment"># Last time that self.heartbeat() was called.</span></div><div class="line">         last_self_heartbeat_time = datetime.now()</div><div class="line">+        <span class="comment"># Last time that self.executor.heartbeat() was called.</span></div><div class="line">+        last_executor_heartbeat_time = datetime.now()</div><div class="line">         <span class="comment"># Last time that the DAG dir was traversed to look for files</span></div><div class="line">         last_dag_dir_refresh_time = datetime.now()</div><div class="line"></div><div class="line"><span class="meta">@@ -1436,9 +1438,14 @@</span></div><div class="line">                 self._execute_task_instances(simple_dag_bag,</div><div class="line">                                              (State.SCHEDULED,))</div><div class="line"></div><div class="line">-            <span class="comment"># Call hearbeats</span></div><div class="line">-            self.logger.info(<span class="string">"Heartbeating the executor"</span>)</div><div class="line">-            self.executor.heartbeat()</div><div class="line">+            <span class="comment"># Heartbeat the executor periodically</span></div><div class="line">+            time_since_last_heartbeat = (datetime.now() -</div><div class="line">+                                         last_executor_heartbeat_time).total_seconds()</div><div class="line">+            <span class="keyword">if</span> time_since_last_heartbeat &gt; self.heartrate:</div><div class="line">+                self.logger.info(<span class="string">"Heartbeating the executor"</span>)</div><div class="line">+                <span class="keyword">try</span>: self.executor.heartbeat()</div><div class="line">+                <span class="keyword">except</span> ConnectionResetError: <span class="keyword">pass</span>  <span class="comment"># RabbitMQ sometimes resets the socket connection</span></div><div class="line">+                last_executor_heartbeat_time = datetime.now()</div><div class="line"></div><div class="line">             <span class="comment"># Process events from the executor</span></div><div class="line">             self._process_executor_events()</div></pre></td></tr></table></figure>
<p><a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> 的介绍与使用就先写到这里，如果读者有与我类似或相同的问题，欢迎评论区探讨。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://airflow.incubator.apache.org/" target="_blank" rel="external">Airflow 官方文档</a></li>
<li><a href="http://morefreeze.github.io/2016/12/airflow.html" target="_blank" rel="external">Airflow 简明指南</a></li>
<li><a href="http://blog.genesino.com/2016/05/airflow/#%E9%85%8D%E7%BD%AEceleryexecutor-rabbitmq%E6%94%AF%E6%8C%81" target="_blank" rel="external">Airflow Useage</a></li>
<li><a href="https://issues.apache.org/jira/browse/AIRFLOW-342" target="_blank" rel="external">Exception in <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">airflow</a> scheduler: Connection reset by peer</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;初识-airflow&quot;&gt;&lt;a href=&quot;#初识-airflow&quot; class=&quot;headerlink&quot; title=&quot;初识 airflow&quot;&gt;&lt;/a&gt;初识 &lt;a href=&quot;https://github.com/apache/incubator-airflow&quot;
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="python, airflow, celery" scheme="http://blog.yinwoods.work/tags/python-airflow-celery/"/>
    
  </entry>
  
  <entry>
    <title>《Fluent Python》读书笔记</title>
    <link href="http://blog.yinwoods.work/2017/07/25/fluent-python-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.yinwoods.work/2017/07/25/fluent-python-读书笔记/</id>
    <published>2017-07-25T06:12:37.000Z</published>
    <updated>2017-07-26T10:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>第二次读Fluent Python了，记得第一次读的时候总有醍醐灌顶的感觉，但迫于当时刚接触python不久，且没有做读书笔记，所以只是看的时候觉得这本书很好，看过就忘了。第二次读，特意买了纸质版，打算将读书过程中的感想、思考都记录下来，以供他人以及未来的自己参考。</p>
<h3 id="第二章-An-Array-of-Sequences"><a href="#第二章-An-Array-of-Sequences" class="headerlink" title="第二章 An Array of Sequences"></a>第二章 An Array of Sequences</h3><ul>
<li>Pg46: 借用二分搜索来实现多重条件判断，这样的操作值得借鉴：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(score, breakpoints=[<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>], grades=<span class="string">'FDCBA'</span>)</span>:</span></div><div class="line">    i = bisect.bisect(breakpoints, score)</div><div class="line">    <span class="keyword">return</span> grades[i]</div></pre></td></tr></table></figure>
<ul>
<li><p>Pg48: 大量数值的读写以及相关操作最好使用针对数值优化的array而不是list</p>
</li>
<li><p>Pg51: 大量数据的复制可以借助memoryview</p>
</li>
</ul>
<h3 id="第三章-Dictionaries-and-Sets"><a href="#第三章-Dictionaries-and-Sets" class="headerlink" title="第三章 Dictionaries and Sets"></a>第三章 Dictionaries and Sets</h3><ul>
<li>Pg70: 在使用dict的过程中，因为很多时候难以确定key是否在dict中存在，因此会先利用get方法取key对应的value，在对value进行一些操作之后再update dict，这样的操作会显得很琐碎，很多时候可以借助dict.setdefault()方法来完成上述一系列操作。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt = dict(one=<span class="number">1</span>, two=<span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt.setdefault(<span class="string">'three'</span>, <span class="number">0</span>)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt.update(&#123;<span class="string">'three'</span>: dt.setdefault(<span class="string">'three'</span>, <span class="number">0</span>) + <span class="number">3</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt</div><div class="line">&#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt.update(&#123;<span class="string">'one'</span>: dt.setdefault(<span class="string">'one'</span>, <span class="number">0</span>) + <span class="number">3</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt</div><div class="line">&#123;<span class="string">'one'</span>: <span class="number">4</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>Pg70: 在dict上做一些操作时，很多时候我们希望直接利用[key]形式取值时不产生<code>KeyError</code>，为了解决这个问题，有两种方案；一种是借用defaultDict，另一种则是继承dict类并自己实现<strong>missing</strong>方法</p>
</li>
<li><p>Pg78: python标准库中并没有提供只读的dict，但是可以借用types中的MappingProxyType来实现相关功能，但需要注意的是MappingProxyType实例会随着传递进来的dict改变而改变</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MappingProxyType</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>: <span class="string">'A'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy = MappingProxyType(d)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy</div><div class="line">mappingproxy(&#123;<span class="number">1</span>: <span class="string">'A'</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">1</span>]</div><div class="line"><span class="string">'A'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">2</span>] = <span class="string">'x'</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: <span class="string">'mappingproxy'</span> object does <span class="keyword">not</span> support item assignment</div><div class="line"><span class="string">'mappingproxy'</span> object does <span class="keyword">not</span> support item assignment</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">2</span>] = <span class="string">'B'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy</div><div class="line">mappingproxy(&#123;<span class="number">1</span>: <span class="string">'A'</span>, <span class="number">2</span>: <span class="string">'B'</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">2</span>]</div><div class="line"><span class="string">'B'</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二次读Fluent Python了，记得第一次读的时候总有醍醐灌顶的感觉，但迫于当时刚接触python不久，且没有做读书笔记，所以只是看的时候觉得这本书很好，看过就忘了。第二次读，特意买了纸质版，打算将读书过程中的感想、思考都记录下来，以供他人以及未来的自己参考。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="python" scheme="http://blog.yinwoods.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python requests库处理302重定向</title>
    <link href="http://blog.yinwoods.work/2017/06/24/python-requests%E5%BA%93%E5%A4%84%E7%90%86302%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://blog.yinwoods.work/2017/06/24/python-requests库处理302重定向/</id>
    <published>2017-06-24T11:10:37.000Z</published>
    <updated>2017-07-26T10:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近接了一个活，给定一些链接，统计每个链接的跳转次数以及最终跳转至的网址。</p>
<p>刚开始是用scrapy写的，通过Google与stack overflow了解到下面这种写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">conn = pymysql.connect(</div><div class="line">        host=<span class="string">'host'</span>,</div><div class="line">        user=<span class="string">'user'</span>,</div><div class="line">        password=<span class="string">'password'</span>,</div><div class="line">        db=<span class="string">'database'</span>)</div><div class="line">cursor = conn.cursor()</div><div class="line"></div><div class="line">sql = <span class="string">'''</span></div><div class="line">    select distinct click_url from table</div><div class="line">    where country = "&#123;&#125;" and status=0'''.format(country)</div><div class="line">cursor.execute(sql)</div><div class="line">urls = cursor.fetchall()</div><div class="line">start_urls = (x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> urls)</div><div class="line"></div><div class="line"><span class="comment"># 无限跳转 测试使用</span></div><div class="line"><span class="comment"># start_urls = ('http://maoshuai.sinaapp.com/cnblog/302test.php', )</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> self.start_urls:</div><div class="line">        <span class="keyword">yield</span> scrapy.Request(url, meta=&#123;<span class="string">'original_url'</span>: url&#125;)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">    <span class="comment"># print('response url', response.url)</span></div><div class="line">    <span class="comment"># print('response status', response.status)</span></div><div class="line">    request = response.request</div><div class="line">    redirected_url = request.url</div><div class="line"></div><div class="line">    original_url = response.meta[<span class="string">'original_url'</span>]</div><div class="line"></div><div class="line">    <span class="keyword">if</span> original_url <span class="keyword">not</span> <span class="keyword">in</span> self.redirect_count.keys():</div><div class="line">        self.redirect_count.update(&#123;original_url: <span class="number">0</span>&#125;)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> response.status &gt;= <span class="number">300</span> <span class="keyword">and</span> response.status &lt; <span class="number">400</span>:</div><div class="line"></div><div class="line">        self.redirect_count[original_url] += <span class="number">1</span></div><div class="line">        location = to_native_str(</div><div class="line">                response.headers[<span class="string">'location'</span>].decode(<span class="string">'latin1'</span>))</div><div class="line">        request = response.request</div><div class="line">        redirected_url = urljoin(request.url, location)</div><div class="line">        <span class="comment"># print('redirected to ', redirected_url)</span></div><div class="line">        <span class="keyword">yield</span> scrapy.Request(</div><div class="line">                redirected_url,</div><div class="line">                meta=&#123;<span class="string">'original_url'</span>: original_url&#125;,</div><div class="line">                callback=self.parse)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        redirected = request.replace(</div><div class="line">                url=redirected_url, method=<span class="string">'GET'</span>, body=<span class="string">''</span>)</div><div class="line">        redirected.headers.pop(<span class="string">'Content-Type'</span>, <span class="keyword">None</span>)</div><div class="line">        redirected.headers.pop(<span class="string">'Content-Length'</span>, <span class="keyword">None</span>)</div><div class="line">        <span class="keyword">yield</span> redirected</div><div class="line"></div><div class="line">    count = self.redirect_count.get(original_url)</div><div class="line">    <span class="keyword">if</span> count &gt;= <span class="number">1</span> <span class="keyword">and</span> response.url.startswith(<span class="string">'https://play.google.com'</span>):</div><div class="line">        print(self.redirect_count.get(original_url))</div><div class="line">        self.update_count(</div><div class="line">                original_url, self.redirect_count.get(original_url))</div></pre></td></tr></table></figure>
<p>大致说一下上面代码的思路，在start_requests中，yield request时携带原始URL，从而利用dict统计该URL的跳转次数；parse函数是核心功能代码，用于处理302重定向，通过递归调用parse函数处理重定向后的URL。</p>
<p>上面这种代码是可行的，但是由于需要在生产环境中运行代码，而自己对上面代码的整个执行流程不够清楚，因此最后还是选用requests库来解决该问题，尽管速度上会慢一些，但是自己对整个程序的执行有更清晰的把控。（PS：也是从这里我意识到当性能不是程序的瓶颈时，一定不要牺牲稳定性来提升程序性能，这种行为带来的代价往往是巨大的！）</p>
<p>改用requests改写后，写起来很轻松，因为使用response.history就可以轻松获取重定向最终链接以及中间重定向次数。具体代码参考<a href="http://docs.python-requests.org/en/master/user/quickstart/" target="_blank" rel="external">requests官方文档</a>即可。</p>
<p>但随后又有了新需求，当使用移动客户端访问这些链接时，链接可能最终跳转至以<code>market://</code>开头的URL，而这种URL会被requests认为是无效URL而报错，为了能够正确处理这种情况，也即获取以<code>market://</code>开头的最终URL以及中间的跳转次数，很明显简单地使用response.history无法达到目的。</p>
<p>当然，如果在访问一个URL时，禁止重定向，然后自行处理重定向过程也是一个可行的办法。但是在实践中遇到302中response的Location字段跳转至本站根域名下的其他链接，也就是说Location字段保存的是一个相对URL，因此自行处理重定向就需要额外处理相对URL，这让重定向问题又一步复杂化，故放弃这个方法。</p>
<p>之后想到的方法是查阅官方文档，相信官方文档应该有对重定向问题更加自定义的支持。果不其然，在官方文档的角落里翻阅到requests中有<code>resolve_redirects()</code>方法，虽然文档中对该方法无较多介绍，但通过Google大法也是找到了一些代码片段，通过对代码进行加工改造，得到能够完美解决我的难题的以下代码版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter_send</span><span class="params">(self, session, request, **kwargs)</span>:</span></div><div class="line">    <span class="comment"># 返回重定向过程中一系列response</span></div><div class="line">    <span class="comment"># 如果最终结果为应用内跳转url，类似market://形式则返回上一个response</span></div><div class="line">    resp = session.send(request, allow_redirects=<span class="keyword">False</span>,</div><div class="line">                        timeout=<span class="number">10</span>, **kwargs)</div><div class="line">    redir_iter = session.resolve_redirects(resp, request, timeout=<span class="number">10</span>)</div><div class="line">    <span class="keyword">while</span> resp.is_redirect:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            resp = next(redir_iter)</div><div class="line">            <span class="keyword">yield</span> resp</div><div class="line">        <span class="keyword">except</span> requests.exceptions.InvalidSchema:</div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="keyword">yield</span> resp</div></pre></td></tr></table></figure>
<p>虽然问题的整个解决过程自己没有进行复杂地编程，但是可以发现代码写的多了能够训练出程序员的一种直觉，接着再去验证自己的直觉往往能够节省很多时间，可见经验的重要性了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近接了一个活，给定一些链接，统计每个链接的跳转次数以及最终跳转至的网址。&lt;/p&gt;
&lt;p&gt;刚开始是用scrapy写的，通过Google与stack overflow了解到下面这种写法：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="python, requests" scheme="http://blog.yinwoods.work/tags/python-requests/"/>
    
  </entry>
  
  <entry>
    <title>BK树数据结构学习</title>
    <link href="http://blog.yinwoods.work/2017/04/09/BK%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://blog.yinwoods.work/2017/04/09/BK树数据结构学习/</id>
    <published>2017-04-08T16:00:00.000Z</published>
    <updated>2017-07-26T10:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>BK树是一种基于树的数据结构，用来快速查找基于编辑距离的相似字符串匹配，比如拼写纠错或模糊查找。许多软件中的自动拼写纠错就是基于这个数据结构来实现的。</p>
<p>BK树中的每一个节点都是词典中的一个单词，而树中的边权重则表明叶子结点到根节点之间的编辑距离。例如从节点u到节点v的边上权重为w，那么w就是把u转化为v的编辑距离。</p>
<p>例如对于词典<code>{&quot;help&quot;, &quot;hell&quot;, &quot;hello&quot;}</code>，其对应的BK树如下：</p>
<p><img src="http://7xlnl2.com1.z0.glb.clouddn.com/2017-04-09-1.png" alt="BK树"></p>
<p>BK树中的每个节点与子节点的编辑距离值都是唯一的，在插入节点的过程中如果编辑距离与当前节点和子节点之间的编辑距离相同，则考虑插入到下一个节点上。BK树每次插入均从根结点开始，根节点可以是词典中的任意一个单词。</p>
<p>例如向上述词典插入新单词<code>shell</code>时插入过程如下：</p>
<ul>
<li>比较shell与根节点help的编辑距离，得到2</li>
<li>发现根节点已经存在编辑距离为2的子节点hello，因此尝试将shell插入到子节点hello上</li>
<li>比较shell与hello的编辑距离，因为hello没有编辑距离为2的子节点，因此插入</li>
</ul>
<p>得到下图：<br><img src="http://7xlnl2.com1.z0.glb.clouddn.com/2017-04-09-2.png" alt="新的BK树"></p>
<p>对于一个给定的TOL（tolerance value）作为编辑距离的上限，我们使用BK树来查找与给定节点N编辑距离小于等于TOL的过程如下：</p>
<blockquote>
<p>计算给定节点N与根节点的编辑距离D，接着继续搜索与根节点编辑距离在[D - TOL, D + TOL]之间的子节点。重复这个过程知道找到所有满足条件的节点。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></div><div class="line">    <span class="built_in">string</span> word;</div><div class="line">    <span class="comment">// next[i]中保存的值为与word编辑距离为i的词在tree中的下标</span></div><div class="line">    <span class="keyword">int</span> next[<span class="number">2</span> * LEN];</div><div class="line"></div><div class="line">    Node(<span class="built_in">string</span> x): word(x) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>*LEN; ++i) &#123;</div><div class="line">            next[i] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Node():word() &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">Node RT;</div><div class="line"><span class="keyword">int</span> dp[<span class="number">2</span> * LEN][<span class="number">2</span> * LEN];</div><div class="line">Node tree[MAXN];</div><div class="line"></div><div class="line"><span class="keyword">int</span> ptr = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> min(min(a, b), c);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">editDistance</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span> </span>&#123;</div><div class="line">    <span class="comment">// 动态规划获取最短编辑距离</span></div><div class="line">    <span class="keyword">int</span> a_len = a.length();</div><div class="line">    <span class="keyword">int</span> b_len = b.length();</div><div class="line"></div><div class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=a_len; ++i)</div><div class="line">        dp[i][<span class="number">0</span>] = i;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=b_len; ++j)</div><div class="line">        dp[<span class="number">0</span>][j] = j;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=a_len; ++i) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=b_len; ++j) &#123;</div><div class="line">            <span class="keyword">if</span>(a[i<span class="number">-1</span>] != b[j<span class="number">-1</span>]) &#123;</div><div class="line">                dp[i][j] = min(<span class="number">1</span> + dp[i<span class="number">-1</span>][j],      <span class="comment">// deletion</span></div><div class="line">                               <span class="number">1</span> + dp[i][j<span class="number">-1</span>],      <span class="comment">// insertion</span></div><div class="line">                               <span class="number">1</span> + dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);   <span class="comment">// replacement</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[a_len][b_len];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Node &amp;root, Node &amp;cur)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(root.word.length() == <span class="number">0</span>) &#123;</div><div class="line">        root = cur;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> distance = editDistance(cur.word, root.word);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(tree[root.next[distance]].word.length() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 若与root编辑距离为distance的位置没有节点，则将该节点标记为叶子结点</span></div><div class="line">        ++ptr;</div><div class="line">        tree[ptr] = cur;</div><div class="line">        root.next[distance] = ptr;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        add(tree[root.next[distance]], cur);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; getSimilarWords(Node &amp;root, <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> TOL) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(root.word == <span class="string">""</span>)</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> distance = editDistance(root.word, s);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(distance &lt;= TOL)</div><div class="line">        ret.push_back(root.word);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> start = distance - TOL;</div><div class="line">    <span class="keyword">if</span>(start &lt; <span class="number">0</span>)</div><div class="line">        start = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(start &lt; distance + TOL) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp = getSimilarWords(tree[root.next[start]], s, TOL);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : tmp) &#123;</div><div class="line">            ret.push_back(i);</div><div class="line">        &#125;</div><div class="line">        ++start;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">string</span> dictionary[] = &#123;<span class="string">"hello"</span>, <span class="string">"help"</span>, <span class="string">"shel"</span>, <span class="string">"smell"</span>, <span class="string">"fell"</span>,</div><div class="line">                           <span class="string">"felt"</span>, <span class="string">"oops"</span>, <span class="string">"pop"</span>, <span class="string">"oouch"</span>, <span class="string">"halt"</span>&#125;;</div><div class="line"></div><div class="line">    ptr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sz = <span class="keyword">sizeof</span>(dictionary) / <span class="keyword">sizeof</span>(<span class="built_in">string</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; ++i) &#123;</div><div class="line">        Node temp = Node(dictionary[i]);</div><div class="line">        add(RT, temp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">string</span> w1 = <span class="string">"ops"</span>;</div><div class="line">    <span class="built_in">string</span> w2 = <span class="string">"helt"</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; match = getSimilarWords(RT, w1, <span class="number">2</span>);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"similar words in dictionary for: "</span> &lt;&lt; w1 &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : match) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"- "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    match = getSimilarWords(RT, w2, <span class="number">2</span>);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"similar words in dictionary for: "</span> &lt;&lt; w2 &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : match) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"* "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BK树的应用：</p>
<p>一般提到BK树，了解这个数据结构的人都会想到单词纠错。而最近看到一遍博文讲述了如何使用BK树实现海量图片的去重（找到与给定图片编辑距离在上限范围内的所有图片并删除），其实仔细想一想对BK树应用的正确理解应该是基于相似度搜索结果，而不应该简单粗暴地理解为单词纠错（其实也是模糊查询）这种典型的应用场景，这样的认知有时候可能会限制我们在实际场景中对脑海中知识的变现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BK树是一种基于树的数据结构，用来快速查找基于编辑距离的相似字符串匹配，比如拼写纠错或模糊查找。许多软件中的自动拼写纠错就是基于这个数据结构来实现的。&lt;/p&gt;
&lt;p&gt;BK树中的每一个节点都是词典中的一个单词，而树中的边权重则表明叶子结点到根节点之间的编辑距离。例如从节点u到
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="data structure" scheme="http://blog.yinwoods.work/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>2016年年终总结</title>
    <link href="http://blog.yinwoods.work/2016/12/30/2016%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.yinwoods.work/2016/12/30/2016年年终总结/</id>
    <published>2016-12-29T16:00:00.000Z</published>
    <updated>2017-07-26T10:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉2016就要结束了,也到了交上自己2016年答卷的时候了。欲扬先抑的2016年年终总结，先从坏消息开始吧。</p>
<h3 id="2016年遗憾的"><a href="#2016年遗憾的" class="headerlink" title="2016年遗憾的"></a>2016年遗憾的</h3><p>其实从自己内心深处来说，没有觉得2016年有什么遗憾，但作为年终总结如果一点遗憾都没有也确实说不过去:)。</p>
<p>最大的遗憾是答应自己去日本旅行的承诺没有做到吧，原因是签证太难办了，尤其对我来说。。。所以暑假的毕业旅行选择了梅开两度——云南，也还算玩的开心吧，不过因为是第二次去，所以某种程度上成了基友团的导游，真真是痛并快乐着。</p>
<h3 id="2016年失去的"><a href="#2016年失去的" class="headerlink" title="2016年失去的"></a>2016年失去的</h3><p>2016年失去了一些坚持了很久的东西，比如对一个人持续了几年的喜欢，当然我承认这种喜欢本身就是不理智、畸形的，不过它也是倾入心血、不求回报的。anyway，路过了，失去了，没什么可遗憾的。</p>
<h3 id="2016年变本加厉的"><a href="#2016年变本加厉的" class="headerlink" title="2016年变本加厉的"></a>2016年变本加厉的</h3><p>2016年的自己人情味好像又跌了。。。以前大概有个50%？现在可能只剩下20-30%了？细思极恐，反思这一年中的自己确实如朋友所说经常摆个臭脸，一脸高冷（非褒义）。虽然和朋友在一起时还可以做到欢声笑语，但大多时候真的是绷着臭脸一言不发啊，也许这也是我研究生入学到现在新认识女生个数为0的原因？哈哈哈。不过话说回来，作为一个20多岁社会人员预备役研究生，这些缺点自己一直是心里有数的，之所以没有改不是因为自己无能为力，而是我需要。三点原因吧:</p>
<ul>
<li><p>实验室的氛围总是透露着迷之尴尬的气息（非常适合现阶段的我），确实不适合整天嘻嘻哈哈、没心没肺的生活；</p>
</li>
<li><p>出于屏蔽外界干扰，专心做事的考虑吧，毕竟精力有限，而且自己想要做的事需要倾入绝大部分精力；</p>
</li>
<li><p>自己一直以来有个臭毛病：太大嘴巴啦。。。所以万言万当，不如一默；</p>
</li>
</ul>
<h3 id="2016年改正的"><a href="#2016年改正的" class="headerlink" title="2016年改正的"></a>2016年改正的</h3><p>首推大嘴巴。。。怎么以前自己想说的话就那么多呢，而且大多数时候都是出于夸耀自己技术上的一些微不足道的小成就。所幸在2016年的小尾巴从手中流逝之际改掉了，其实2015年自己社交圈子基本全部噤声，怎么2016年就像打了鸡血一样，一直BB叨BB叨。。。当然之所以改掉了这个缺点倒不只是说在社交圈子内发声变少，而是源于对自己内心深处的审视，未来自己觉得好的东西可能还是会分享，可是不再希望全世界都知道了，毕竟生活是自己的。</p>
<h3 id="2016年收获的"><a href="#2016年收获的" class="headerlink" title="2016年收获的"></a>2016年收获的</h3><p>说了一堆，终于要迈入博客正题了，其实2016年归根到底，自己的收获远远大于收入的，也不局限于技术方面，而是涵盖生活的各个方面，下面娓娓道来，也算是对自己2016年的收获做一个梳理吧。</p>
<h4 id="技术上收获的"><a href="#技术上收获的" class="headerlink" title="技术上收获的"></a>技术上收获的</h4><p>作为一个程序猿，要是年度总结丝毫不提技术，那这一年得是过得多失败啊:P。2016年可以算是自己正式迈入计算机技术大门门槛的一年吧（现在确实是这么觉得，不知道以后会不会打脸，不过成长不就是不断打脸的过程吗），这一年可以清楚地察觉到自己突破了长期以来的技术瓶颈，本科四年自己很努力，可是苦于没有一个可供深耕的方向，学了一大堆东西，到头来发现能记住、在生活中能运用到的的却寥寥无几。不过也正是因为以前自己学的太杂，所以有了今天的量变到质变转化的过程。引发质变的原因总结下来有以下几个方面吧：</p>
<ul>
<li><p>实习呆的公司是初创公司，什么基础设施都有自己搭建，所以得到了极大的锻炼，外加领导相当有节奏的push，所以成长速度远快于在学校的日子；</p>
</li>
<li><p>进入了一个更高的平台，接触的人、技术也处于一个更高的层次，因此能够在实际生活中从身边的朋友、同事身上学习很多；</p>
</li>
<li><p>在实习过程中对一个程序猿的成长曲线有了一个大致的认知，所以对自己的发展路线也有了一个大致规划；</p>
</li>
<li><p>度过了2015年的舒适区，进入了一个忙碌的阶段，这种突变的环境往往也会导致一个人的突变（for me, technologically）；</p>
</li>
<li><p>自己暑假期间开始阅读英文技术书籍并 <strong>读完</strong> ，放佛打开了新世界的大门啊。。。如果是中文技术资料是V0.1的话，英文资料完全是V2.0啊！！真的强烈推荐做技术的朋友好好学英语， 它远比你想象中有用地多得多；</p>
</li>
</ul>
<p>之所以说这一年自己的技术上产生了质变，原因是现在的自己感觉学什么东西都相当快（对比以前的自己来说）。举几个例子：</p>
<ul>
<li><p>现在可以不客气地说自己熟练掌握了python，原因不仅仅是写了几万行python代码那么简单，学习过程中可是查阅了数量相当庞大的python英文资料啊；</p>
</li>
<li><p>十几天过了一遍《Linux Command Guide》，再加上实习过程中经常亲眼目睹boss使用linux的花式组合命令，自己现在对linux也能够熟练使用了，熟悉后愈发觉得linux是效率神器，使用起来游刃有余。</p>
</li>
<li><p>几天过了一遍《Learn the vi and vim Editors》，对vim的使用以及linux shell的使用自定义配置都有了一定的了解，同效率神器。。。为什么自己现在才深入学习啊啊啊啊</p>
</li>
<li><p>实习过程中完全是ssh远程操作，尤其是大数据相关操作编写mapreduce任务、部署定时任务、搭建docker开发环境以及python tornado后台开发等等。。。</p>
</li>
</ul>
<p>总之，在16年年底回首这一年，我对自己的技术成长是相当满意的，同时也对2017年的自己乃至未来的自己有了更多信心。</p>
<h4 id="心灵上收获的"><a href="#心灵上收获的" class="headerlink" title="心灵上收获的"></a>心灵上收获的</h4><p>16年真的是自己人生迈向新阶段的元年，想想15年的自己颓地就差自暴自弃了。。。现在则对自己有着足够的信心，这些信心源于对自己的认知，认清了自己是怎样的，身边人是怎样的，这个社会又是怎样的，付出了那么多，有什么理由不自信呢？我想一个人的成长过程就是这样吧，此起彼伏、上上下下，可是随着时间的流逝，我们对自己的认知终会趋向于一个理性的区间，说着说着又有些期待下次颓废的自己了，要再遇到什么样的大牛，承受什么样的吊打呢？</p>
<p>自己另一个变化就是能够更清晰地审视自己的未来了吧，提及梦想，自己就充满了斗志。。。干劲十足，打鸡血状态。这种状态吧，就好比有些淘气的小孩子想要吃糖，爸爸妈妈不给，那他哭哑了嗓子也要吃到那块糖，我现在就是这样。。。有些事是真的无论如何也要做到，这么说可能不太合适，是有些事无论如何也要尽力做到吧。哪怕这条路要一个人走，要牺牲很多。但心甘情愿，只有这样自己才会感到开心。</p>
<p>最后一点就是自己一直以来想做的一个改变了，也是我认为自己以前最缺的一点吧：闷声发大财，这样才是最好的，哈哈哈。2017年要低调地划过去～</p>
<h3 id="写过的代码"><a href="#写过的代码" class="headerlink" title="写过的代码"></a>写过的代码</h3><p>今年github提交主要还是自己的博客，忏愧。。。</p>
<p>另外九月份自己写了个针对北航垃圾系统的爬虫爬取个人课表。</p>
<p>明年再接再厉~</p>
<p><img src="http://7xlnl2.com1.z0.glb.clouddn.com/post59-github.jpg" alt="Github"></p>
<h4 id="读过的书"><a href="#读过的书" class="headerlink" title="读过的书"></a>读过的书</h4><p>现在的社交媒体上好像总是倾向于把读书宣扬为一件很优雅、高端的行为。无解。在我眼里它和看电影没什么区别，况且很多人读再多的书脑子里的思想也是臭不可闻。读过的书目、走过的路途，恕我直言，和一个人的三观修养不见得是一个正比例函数，重要的是这些过程中自己的思考吧。所以身边如果有人说他在读鲁迅、茨威格、村上春树等等，我哪怕在读的是街边黄色小书刊也不会觉得自己姿势就低到哪里去了。言归正传，16年读的还是小说、技术书籍居多，有下面这些吧：</p>
<ul>
<li><p>一月：准风月谈</p>
</li>
<li><p>二月：文化的力量</p>
</li>
<li><p>四月：性爱与婚姻、乔家大院、边城</p>
</li>
<li><p>五月：西游记</p>
</li>
<li><p>六月：封神演义、红高粱</p>
</li>
<li><p>七月： <strong>退后，我要开始装逼了。。。</strong> Learn C the Hard Way、操作系统思考、论持久战、行者无疆</p>
</li>
<li><p>八月：Fluent Python、Python Cookbook 3rd Edition、Code Like a Pythonista Idiomatic Python、Intermediate Python、Web Scraping with Python</p>
</li>
<li><p>九月：一个陌生女人的来信</p>
</li>
<li><p>十月：Algorithm Unplugged</p>
</li>
<li><p>十一月：The Linux Command Line、 Pro Git</p>
</li>
<li><p>十二月：Learn the Vi and Vim、Hadoop with Python</p>
</li>
</ul>
<h4 id="看过的电影"><a href="#看过的电影" class="headerlink" title="看过的电影"></a>看过的电影</h4><p>看过的电影还真不少，主要集中在上半年的实习过程中，研究生入学以后最新科研，看得电影也少了。。。</p>
<p>详情见<a href="https://movie.douban.com/standbyme/2016/share?source=broadcast&amp;user_id=79236503" target="_blank" rel="external">链接</a></p>
<h4 id="听过的歌"><a href="#听过的歌" class="headerlink" title="听过的歌"></a>听过的歌</h4><p>16年因为实习过程中在路上的时间很多，所以听的歌也很多，一年大概听了有3000+首？也是在这一年确定了自己最爱的音乐类型：电音；</p>
<h4 id="去过的地方"><a href="#去过的地方" class="headerlink" title="去过的地方"></a>去过的地方</h4><p>说来忏愧，今年真的是没去哪里浪，最起码和自己的预期还是有很大差距的。远的地方就去了南京、扬州、昆明、大理；近的地方则去了香山（自己说出来都嫌丢人。。。）、青龙峡、十渡。</p>
<h4 id="亲情上收获的"><a href="#亲情上收获的" class="headerlink" title="亲情上收获的"></a>亲情上收获的</h4><p>因为是个人总结，所以不想深谈自己的家庭等等。总之16年一切都迈上了正规，作为掌舵人，会让一切越来越好。</p>
<p><img src="http://7xlnl2.com1.z0.glb.clouddn.com/post59-2017.jpg" alt="2017"></p>
<h3 id="2017期待的"><a href="#2017期待的" class="headerlink" title="2017期待的"></a>2017期待的</h3><p>说完了16年的总结，免不了俗地要谈谈17年的小目标了，给自己立几个够得着的FLAG（话说立过的FLAG好像还没倒过）。</p>
<h4 id="技术上"><a href="#技术上" class="headerlink" title="技术上"></a>技术上</h4><p>上半年会继续深入后端，上半年仍然以python作为主力开发语言，其中函数式编程与协程是自己的两个主要突破点，另外继续深入学习使用linux、vim、python web开发框架。</p>
<p>下半年则会系统地过一遍C++，掌握网络、操作系统等知识（主要指一些较低层的知识）。</p>
<p>自己打算掌握的一些零碎或目前还一直半解的相关概念，完善知识体系：</p>
<ul>
<li><p>redis、memcache</p>
</li>
<li><p>hadoop架构及生态</p>
</li>
<li><p>docker重度使用</p>
</li>
<li><p>unikernel使用</p>
</li>
<li><p>NoSQL非结构化数据库</p>
</li>
<li><p>深度学习的应用及前景</p>
</li>
</ul>
<p>另外计划开发一个针对实验室报销的报账系统，节省自己报账时间；还有系统地读一些Github优质源代码，书签里已经躺了几个。</p>
<p>当然，重头戏总要放在最后，17年打算迈入前端大门，就以自己的博客为实验小白鼠，边学边练，将博客来一次彻头彻尾的改变（做的过程中学会以产品的角度来看待整个博客）。</p>
<p>最后实现将自己技术体系中前端、后端打通的目标。但应该仍然会以后端为主（但也不排除学习过程中发现前端太好玩，转前端为主的可能性）。</p>
<h4 id="性格上"><a href="#性格上" class="headerlink" title="性格上"></a>性格上</h4><p>性格上想要改变的地方有：</p>
<ul>
<li><p>改善自己绷着个脸的臭毛病（不是根除）</p>
</li>
<li><p>学会寒暄，神特么秘制技能，我现在是真的一点不会</p>
</li>
<li><p>多看少说</p>
</li>
<li><p>急人所需，多关心身边的朋友、亲人</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉2016就要结束了,也到了交上自己2016年答卷的时候了。欲扬先抑的2016年年终总结，先从坏消息开始吧。&lt;/p&gt;
&lt;h3 id=&quot;2016年遗憾的&quot;&gt;&lt;a href=&quot;#2016年遗憾的&quot; class=&quot;headerlink&quot; title=&quot;2016年遗憾的&quot;&gt;&lt;
    
    </summary>
    
      <category term="diary" scheme="http://blog.yinwoods.work/categories/diary/"/>
    
    
      <category term="thoughts" scheme="http://blog.yinwoods.work/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title>vim 学习笔记</title>
    <link href="http://blog.yinwoods.work/2016/12/04/vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.yinwoods.work/2016/12/04/vim学习笔记/</id>
    <published>2016-12-03T16:00:00.000Z</published>
    <updated>2017-07-26T10:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Chapter-3-Moving-Around-in-a-Hurry"><a href="#Chapter-3-Moving-Around-in-a-Hurry" class="headerlink" title="Chapter 3 Moving Around in a Hurry"></a>Chapter 3 Moving Around in a Hurry</h3><p>^F: scroll forward one screen.<br>^B: scroll backward one screen.</p>
<p>^D: scroll forward half screen.<br>^U: scroll backward half screen.</p>
<p>^E: scroll forward one line.<br>^Y: scroll backward one line.</p>
<p>zENTER: move current line to top of screen and scroll.<br>z.: move current line to center of screen and scroll.<br>z-: move current line to bottom of screen and scroll.</p>
<p>H: move to home-the top line of screen.<br>M: move to middle line of screen.<br>L: move to bottom line of screen.</p>
<p>ENTER: move to first character of next line.<br>+: move to first character of next line.<br>-: move to first character of previous line.</p>
<p>^: move to first nonblank character of current line.<br>n|: move to column n of current line.</p>
<p>e: move to end of word.<br>E: move to end of ward(ignore punctuation)</p>
<p>(: move to begining of current sentence.<br>): move to begining of next sentence.</p>
<p>{: move to begining of current paragraph.<br>}: move to begining of next paragraph.</p>
<p>[[: move to begining of current section.<br>]]: move to begining of next section.</p>
<p>/pattern: search forward for pattern.<br>?pattern: search backward for pattern.</p>
<p>n: repeat last search.<br>N: repeat last search in opposite direction.</p>
<p>/: repeat last search forward.<br>?: repeat last search backward.</p>
<p>fx: find next occurrence of x in the line, where x stands for any character.<br>Fx: find previous occurrence of x in the line.</p>
<p>tx: find character before next occurrence of x in the line.<br>Tx: find character after previous occurrence of x in the line.</p>
<p>;: repeat previous find command in same direction.<br>,: repeat previous find command in opposite direction.</p>
<p><code>: returns you to your original position(the position where you issued the last G command).
&#39;&#39;: act same as</code>, except that it returns the cursor to the begining of the line.</p>
<p>^G: show current line(not a movement command)</p>
<h3 id="Chapter-4-Beyond-the-Basics"><a href="#Chapter-4-Beyond-the-Basics" class="headerlink" title="Chapter 4 Beyond the Basics"></a>Chapter 4 Beyond the Basics</h3><p>vim +n file: opens file at line number n<br>vim + file: opens file at last line<br>vim +/pattern file: opens file at the first occurence of pattern<br>vim -c command file: run command after opening file, usually a line number or a search.</p>
<p>vim -R file: operate in read-only mode.<br>vim -r file: recover files after a crash.<br>view file: to look at a file in read-only mode.</p>
<p>“[a-z]command: do command with buffer [a-z].<br>“[a-z]p: put the contents of buffer [a-z] after cursor.<br>“[A-Z]command: accumulate the text dealed by command to buffer named [a-z].</p>
<p>mx: mark current position with x.<br>‘x: move cursor to first character of the line marked by x.<br>`x: move cursor to character marked by x.<br>``: return to exact position of previous mark or context after a move.<br>‘’: return to begining of the line of previous mark or context.</p>
<h3 id="Chapter-5-Introducint-the-ex-Editor"><a href="#Chapter-5-Introducint-the-ex-Editor" class="headerlink" title="Chapter 5 Introducint the ex Editor"></a>Chapter 5 Introducint the ex Editor</h3><p>=: print total number of lines.<br>.=: print line number of current line.<br>/pattern/=: print line number of first line that matches pattern.</p>
<p>start,end[delete|d]: delete lines.<br>start,end[move|m]number: move lines from start through end to number line.<br>start,end[copy|co|t]number: copy lines from start through end to number line.</p>
<p>/pattern/d: delete next line containing pattern.<br>/pattern/+d: delete line below next line containing pattern.<br>/patter1/,/pattern2/d: delete from first line containing patter1 through first line containing pattern2.</p>
<p>g/pattern: find last occurence of pattern in file.<br>g/pattern/p: find and display all lines in file containing pattern.<br>g!/pattern/nu: find and diaplay all lines in file that don’t contain pattern;also display the line number for each line found.</p>
<p>[read|r] filename: read in contents of another file with ex command. </p>
<h3 id="Chapter-6-Global-Replacement"><a href="#Chapter-6-Global-Replacement" class="headerlink" title="Chapter 6 Global Replacement"></a>Chapter 6 Global Replacement</h3><p>put troff italicization codes around the wrod ENTER: :%s/ENTER/\fI&amp;\fP/g</p>
<p>modify a list of pathnames in a file: :%s:/home/time:/home/linda:g</p>
<p>put html italicization codes around the wrod ENTER: :%s:ENTER:<i>&amp;</i>:g</p>
<p>change all periods to semicolons in lines 1 to 10: :1,10s/./;/g</p>
<p>change all occurrences of the word help (or Help) to HELP: :%s/[Hh]elp/HELP/g</p>
<p>replace one or more spaces with a single space: :%s/  */ /g</p>
<p>replace one or more spaces following a colon with two spaces: :%s/:  */:  /g</p>
<p>replace one or more spaces following a period or a colon with two spaces: :%s/([:.])  */\1  /g</p>
<p>standardize various uses of a word or heading: :%s/^Note[ :s]*/Notes: /g</p>
<p>delete all blank lines: :g/^$/d</p>
<p>delete all blank lines, plus any lines that contain only whitespace: :g/^[ tab]*$/d</p>
<p>delete all leading spaces on every line: :%s/^  <em>(.</em>)/\1/</p>
<p>delete all spaces at the end of every line: :%s/(.<em>)  </em>$/\1/</p>
<p>insert a &gt;  at the start of every line in a file: :%s/^/&gt;  /</p>
<p>add a period to the end of the next six lines: :.,+5s/$/./</p>
<p>reverse the order of all hyphen-separated items in a list: :%s/(.<em>) - (.</em>)/\2 - \1/</p>
<p>change every letter in a file to uppercase: :%s/.*/\U&amp;/</p>
<p>reverse the order of lines in a file: :g/.*/mo0</p>
<p>in a text-file database, on all lines not marked Paid in full, append the phrase Overdue: :g!/Paid in full/s/$/ Overdue/</p>
<p>for any line that doesn’t begin with a number, move the line to the end of the file: :g!/^[[:digit:]]/m$</p>
<p>remove numbering from section headings in a document: :%s/^[1-9][0-9]<em>.[1-9][0-9.]</em> //</p>
<h3 id="Chapter-7-Advanced-Editing"><a href="#Chapter-7-Advanced-Editing" class="headerlink" title="Chapter 7 Advanced Editing"></a>Chapter 7 Advanced Editing</h3><p>execute unix command: !command<br>enter shell without exit vim: !sh</p>
<p>examples: r!date, r!sort file, !ls</p>
<p>filter text in ex: start,end!sort</p>
<p>word abbreviation: ab abbr phrase</p>
<p>disable abbreviation: unab abbr</p>
<p>map x sequence : define character x as a sequence of editing commands.<br>unmap x: disable the squence defined for x.<br>map: list the characters that are currently mapped.</p>
<h3 id="Chapter-11-Multiple-Windows-in-Vim"><a href="#Chapter-11-Multiple-Windows-in-Vim" class="headerlink" title="Chapter 11: Multiple Windows in Vim"></a>Chapter 11: Multiple Windows in Vim</h3><p>vim -o[number] file1 file2: opens the edit session with display hrizontally split into number(default is two) equal-sized windows, one for each file.</p>
<p>[n]split [++opt] [+cmd] [file]:<br>n: tells how many lines to display in the new window, which goes at the top.<br>opt: passes vim option information to the new window session (note that it must be preceded by two plus signs).<br>cmd: passes a command for execution in the new window (note that it must be preceded by a single plus sign).<br>file: specifies a file to edit in the new window.</p>
<p>sviw filename: splits screen horizontally to open a new window and sets readonly for that buffer.<br>sfind [++opt] [+cmd] filename: works like :split, but looks for filename in path. if vim does not find the file, it doesn’t split the window.</p>
<p>resize -n: decrease current window size, default amount is one line.<br>resize +n: increase current window size, default amount is one line.</p>
<p>resize n: set current window height, default is to maximize window height.<br>vertical resize n: set current window width to n. default is to make window as wide as possible.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Chapter-3-Moving-Around-in-a-Hurry&quot;&gt;&lt;a href=&quot;#Chapter-3-Moving-Around-in-a-Hurry&quot; class=&quot;headerlink&quot; title=&quot;Chapter 3 Moving Around 
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="tools, linux" scheme="http://blog.yinwoods.work/tags/tools-linux/"/>
    
  </entry>
  
  <entry>
    <title>含随机指针的单链表/二叉树的深度拷贝</title>
    <link href="http://blog.yinwoods.work/2016/10/24/%E5%90%AB%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%8B%B7%E8%B4%9D/"/>
    <id>http://blog.yinwoods.work/2016/10/24/含随机指针的单链表二叉树的深度拷贝/</id>
    <published>2016-10-23T16:00:00.000Z</published>
    <updated>2017-07-26T10:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、包含随机指针的单链表的深度拷贝"><a href="#一、包含随机指针的单链表的深度拷贝" class="headerlink" title="一、包含随机指针的单链表的深度拷贝"></a>一、包含随机指针的单链表的深度拷贝</h3><p>最近遇到一道很有趣的题目：<code>给定每个节点都包含随机指针的单链表，问如何深度拷贝这个单链表？</code></p>
<p>类似的单链表如图所示：</p>
<p><img src="http://7xlnl2.com1.z0.glb.clouddn.com/post57-2.jpg" alt="图1"></p>
<p>总结了下看到的答案，大致可分为三种方法：</p>
<h4 id="1、暴力复制（很朴素的方法）"><a href="#1、暴力复制（很朴素的方法）" class="headerlink" title="1、暴力复制（很朴素的方法）"></a>1、暴力复制（很朴素的方法）</h4><p>因为随机指针可能指向当前节点之后的节点，所以考虑分两步来做。</p>
<p>第一步遍历单链表，拷贝节点及节点的next指针，不考虑节点的random指针。结束后得到一个新的单链表。</p>
<p>第二步遍历原单链表，如果当前访问节点A有random指针指向节点B，则在新的单链表中找到相应的节点AA以及random所指向节点BB，令AA-&gt;random = BB。</p>
<p>时间复杂度：O(N2)</p>
<h4 id="2、通过节点映射关系实现深度拷贝"><a href="#2、通过节点映射关系实现深度拷贝" class="headerlink" title="2、通过节点映射关系实现深度拷贝"></a>2、通过节点映射关系实现深度拷贝</h4><p>考虑第一种方法可以发现时间主要耗费在复制random指针的过程中需要查找相应的节点，因此可想到如果能够建立原单链表与新单链表节点之间的映射关系，那么只需遍历一次即可完成random指针的拷贝。详细步骤如下：</p>
<p>第一步遍历单链表，拷贝节点及节点的next指针，不考虑节点的random指针。结束后得到一个新的单链表。</p>
<p>第二步遍历原单链表，如果当前访问节点A有random指针指向节点B，则令map[A]-&gt;random = map[B]即可。</p>
<p>故只需要两次遍历，时间复杂度为O(2N)</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> key;</div><div class="line">    Node *next, *random;</div><div class="line">    Node(<span class="keyword">int</span> k, Node *nt, Node *rand): key(k), next(nt), random(rand) &#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInOrder</span><span class="params">(Node *node)</span> </span>&#123;</div><div class="line"></div><div class="line">    Node* curNode = node;</div><div class="line">    <span class="keyword">while</span>(curNode != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"[ "</span> &lt;&lt; curNode-&gt;key &lt;&lt; <span class="string">", "</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(curNode-&gt;random == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL ] -&gt; "</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; curNode-&gt;random-&gt;key &lt;&lt; <span class="string">" ] -&gt; "</span>;</div><div class="line">        &#125;</div><div class="line">        curNode = curNode-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Node* <span class="title">copyLinkedList</span><span class="params">(Node* treeNode, <span class="built_in">map</span>&lt;Node*, Node*&gt; *mymap)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(treeNode == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    Node* headNode = <span class="keyword">new</span> Node(treeNode-&gt;key, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Node* curNode = headNode;</div><div class="line">    (*mymap)[treeNode] = headNode;</div><div class="line"></div><div class="line">    treeNode = treeNode-&gt;next;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(treeNode != <span class="literal">NULL</span>) &#123;</div><div class="line"></div><div class="line">        Node* cloneNode = <span class="keyword">new</span> Node(treeNode-&gt;key, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">        (*mymap)[treeNode] = cloneNode;</div><div class="line"></div><div class="line">        curNode-&gt;next = cloneNode;</div><div class="line">        curNode = curNode-&gt;next;</div><div class="line">        treeNode = treeNode-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> headNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyRandom</span><span class="params">(Node* treeNode, Node* cloneNode, <span class="built_in">map</span>&lt;Node*, Node*&gt; *mymap)</span> </span>&#123;</div><div class="line"></div><div class="line">    Node* headNode = cloneNode;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(treeNode != <span class="literal">NULL</span>) &#123;</div><div class="line">        cloneNode-&gt;random = (*mymap)[treeNode-&gt;random];</div><div class="line"></div><div class="line">        treeNode = treeNode-&gt;next;</div><div class="line">        cloneNode = cloneNode-&gt;next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    cloneNode = headNode;</div><div class="line">    <span class="keyword">return</span> ;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Node* <span class="title">cloneList</span><span class="params">(Node* tree)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="built_in">map</span>&lt;Node*, Node*&gt; *mymap = <span class="keyword">new</span> <span class="built_in">map</span>&lt;Node*, Node*&gt;;</div><div class="line"></div><div class="line">    Node* newList = copyLinkedList(tree, mymap);</div><div class="line"></div><div class="line">    copyRandom(tree, newList, mymap);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> newList;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line"></div><div class="line">    Node* node1 = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Node* node2 = <span class="keyword">new</span> Node(<span class="number">2</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Node* node3 = <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Node* node4 = <span class="keyword">new</span> Node(<span class="number">4</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    node1-&gt;next = node2;</div><div class="line">    node2-&gt;next = node3;</div><div class="line">    node3-&gt;next = node4;</div><div class="line"></div><div class="line">    node1-&gt;random = node3;</div><div class="line">    node2-&gt;random = node4;</div><div class="line"></div><div class="line">    printInOrder(node1);</div><div class="line"></div><div class="line">    Node* clone = cloneList(node1);</div><div class="line"></div><div class="line">    printInOrder(clone);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、在原单链表上插入节点并删除实现深度拷贝"><a href="#3、在原单链表上插入节点并删除实现深度拷贝" class="headerlink" title="3、在原单链表上插入节点并删除实现深度拷贝"></a>3、在原单链表上插入节点并删除实现深度拷贝</h3><p>基本思想同2相似，通过减少查找节点的时间来提高效率。在原单链表中每个节点之后插入一个新节点，如下图所示：</p>
<p><img src="http://7xlnl2.com1.z0.glb.clouddn.com/post57-3.jpg" alt="图2"></p>
<p>当拷贝random指针时就可以通过以下代码实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A-&gt;next-&gt;random = A-&gt;random-&gt;next</div><div class="line"></div><div class="line"># 恢复原单链表</div><div class="line">A-&gt;next = A-&gt;next-&gt;next</div></pre></td></tr></table></figure>
<p><strong> 其实这也是一种特殊的节点映射关系 </strong>。故时间复杂度同2为O(2N)</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> key;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>, *<span class="title">random</span>;</span></div><div class="line">    Node(<span class="keyword">int</span> k, Node* nt, Node* rand): key(k), next(nt), random(rand) &#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 打印链表，[a, b] 表示 key 为 a 的节点 random 指针指向 key 为 b 的节点</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInorder</span><span class="params">(Node* node)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[ "</span> &lt;&lt; node-&gt;key &lt;&lt; <span class="string">" "</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(node-&gt;random == <span class="literal">NULL</span>)</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL ], "</span>;</div><div class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; node-&gt;random-&gt;key &lt;&lt; <span class="string">" ], "</span>;</div><div class="line"></div><div class="line">    printInorder(node-&gt;next);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 复制每个节点（不包含随机指针），并返回第一个复制的节点 </span></div><div class="line"><span class="function">Node* <span class="title">copyLinkedListNode</span><span class="params">(Node* treeNode)</span> </span>&#123;</div><div class="line">    Node* curNode = treeNode;</div><div class="line">    <span class="keyword">while</span>(curNode != <span class="literal">NULL</span>) &#123;</div><div class="line">        Node* next = curNode-&gt;next;</div><div class="line">        curNode-&gt;next = <span class="keyword">new</span> Node(curNode-&gt;key, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">        curNode-&gt;next-&gt;next = next;</div><div class="line">        curNode = next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> treeNode-&gt;next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 复制随机指针</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyRandomNode</span><span class="params">(Node* treeNode, Node* cloneNode)</span> </span>&#123;</div><div class="line">    Node *headNode = cloneNode;</div><div class="line">    <span class="keyword">while</span>(treeNode != <span class="literal">NULL</span>) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(treeNode-&gt;random != <span class="literal">NULL</span>)</div><div class="line">            cloneNode-&gt;random = treeNode-&gt;random-&gt;next;</div><div class="line">        <span class="keyword">else</span> cloneNode-&gt;random = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(treeNode-&gt;next == <span class="literal">NULL</span> || cloneNode-&gt;next == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span> ;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            treeNode = treeNode-&gt;next-&gt;next;</div><div class="line">            cloneNode = cloneNode-&gt;next-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cloneNode = headNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 恢复原来的单链表，即分离两个单链表</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">restoreLinkedList</span><span class="params">(Node* treeNode, Node* cloneNode)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span>(treeNode != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(cloneNode-&gt;next != <span class="literal">NULL</span>) &#123;</div><div class="line">            Node* cloneNext = cloneNode-&gt;next-&gt;next;</div><div class="line">            treeNode-&gt;next = treeNode-&gt;next-&gt;next;</div><div class="line">            cloneNode-&gt;next = cloneNext;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            treeNode-&gt;next = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        treeNode = treeNode-&gt;next;</div><div class="line">        cloneNode = cloneNode-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 复制整个单链表</span></div><div class="line"><span class="function">Node* <span class="title">cloneLinkedList</span><span class="params">(Node* treeNode)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(treeNode == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    Node* cloneNode = copyLinkedListNode(treeNode);</div><div class="line">    copyRandomNode(treeNode, cloneNode);</div><div class="line">    restoreLinkedList(treeNode, cloneNode);</div><div class="line">    <span class="keyword">return</span> cloneNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    Node* node1 = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Node* node2 = <span class="keyword">new</span> Node(<span class="number">2</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Node* node3 = <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Node* node4 = <span class="keyword">new</span> Node(<span class="number">4</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    node1-&gt;next = node2;</div><div class="line">    node2-&gt;next = node3;</div><div class="line">    node3-&gt;next = node4;</div><div class="line">    node1-&gt;random = node3;</div><div class="line">    node2-&gt;random = node4;</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"traversal of original binary tree is: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    printInorder(node1);</div><div class="line"></div><div class="line">    Node *clone = cloneLinkedList(node1);</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\ntraversal of cloned binary tree is: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    printInorder(clone);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二、包含随机指针的二叉树深度拷贝"><a href="#二、包含随机指针的二叉树深度拷贝" class="headerlink" title="二、包含随机指针的二叉树深度拷贝"></a>二、包含随机指针的二叉树深度拷贝</h3><p>同上，这里也有三种对应的方法。</p>
<h3 id="1、暴力复制（OTZ）"><a href="#1、暴力复制（OTZ）" class="headerlink" title="1、暴力复制（OTZ）"></a>1、暴力复制（OTZ）</h3><p>就是暴力。。。时间复杂度为O(N2)</p>
<h3 id="2、通过节点映射关系实现深度拷贝-1"><a href="#2、通过节点映射关系实现深度拷贝-1" class="headerlink" title="2、通过节点映射关系实现深度拷贝"></a>2、通过节点映射关系实现深度拷贝</h3><p>同单链表中节点建立映射关系一样，这里的时间复杂度同样为O(2N)。</p>
<p>具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></div><div class="line">	<span class="keyword">int</span> key;</div><div class="line">	Node *left, *right, *random;</div><div class="line">	Node(<span class="keyword">int</span> k, Node* l, Node* r, Node* rand) : key(k), left(l), right(r), random(rand) &#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 按中序遍历递归打印树</span></div><div class="line"><span class="comment">// 其中[a, b]表示节点a的key值与random指针所指节点的key值</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInorder</span><span class="params">(Node* node)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(node == <span class="literal">NULL</span>) </div><div class="line">		<span class="keyword">return</span> ;</div><div class="line"></div><div class="line">	printInorder(node-&gt;left);</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"[ "</span> &lt;&lt; node-&gt;key &lt;&lt; <span class="string">" "</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(node-&gt;random == <span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL ], "</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; node-&gt;random-&gt;key &lt;&lt; <span class="string">" ], "</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	printInorder(node-&gt;right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 拷贝以treeNode为根节点的整棵树并返回拷贝完成后新的根节点</span></div><div class="line"><span class="comment">// 拷贝过程中包含所有节点的左右孩子，但不包含节点的random指针</span></div><div class="line"><span class="function">Node* <span class="title">copyLeftRightNode</span><span class="params">(Node* treeNode, <span class="built_in">map</span>&lt;Node *, Node *&gt; *mymap)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(treeNode == <span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	Node* cloneNode = <span class="keyword">new</span> Node(treeNode-&gt;key, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">	<span class="comment">// 建立当前节点到克隆节点的映射</span></div><div class="line">	(*mymap)[treeNode] = cloneNode;</div><div class="line">	cloneNode-&gt;left = copyLeftRightNode(treeNode-&gt;left, mymap);</div><div class="line">	cloneNode-&gt;right = copyLeftRightNode(treeNode-&gt;right, mymap);</div><div class="line">	<span class="keyword">return</span> cloneNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 遍历并拷贝random指针</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyRandom</span><span class="params">(Node* treeNode, Node* cloneNode, <span class="built_in">map</span>&lt;Node*, Node*&gt; *mymap)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(cloneNode == <span class="literal">NULL</span>)</div><div class="line">		<span class="keyword">return</span> ;</div><div class="line">	cloneNode-&gt;random = (*mymap)[treeNode-&gt;random];</div><div class="line">	copyRandom(treeNode-&gt;left, cloneNode-&gt;left, mymap);</div><div class="line">	copyRandom(treeNode-&gt;right, cloneNode-&gt;right, mymap);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 克隆整棵树的函数主体</span></div><div class="line"><span class="function">Node* <span class="title">cloneTree</span><span class="params">(Node* tree)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(tree == <span class="literal">NULL</span>)</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 创建节点到节点的映射</span></div><div class="line">	<span class="built_in">map</span>&lt;Node*, Node*&gt; *mymap = <span class="keyword">new</span> <span class="built_in">map</span>&lt;Node*, Node*&gt;;</div><div class="line"></div><div class="line">	<span class="comment">// 第一次遍历只拷贝树中每个节点的左右孩子</span></div><div class="line">	<span class="comment">// 也就是说暂时不拷贝random指针</span></div><div class="line">	Node* newTree = copyLeftRightNode(tree, mymap);</div><div class="line"></div><div class="line">	<span class="comment">// 第二次遍历拷贝random指针</span></div><div class="line">	copyRandom(tree, newTree, mymap);</div><div class="line">	<span class="keyword">return</span> newTree;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line"></div><div class="line">	Node *tree = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">	tree-&gt;left = <span class="keyword">new</span> Node(<span class="number">2</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">	tree-&gt;right = <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">	tree-&gt;left-&gt;left = <span class="keyword">new</span> Node(<span class="number">4</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">	tree-&gt;left-&gt;right = <span class="keyword">new</span> Node(<span class="number">5</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">	tree-&gt;random = tree-&gt;left-&gt;right;</div><div class="line">	tree-&gt;left-&gt;right-&gt;random = tree-&gt;right;</div><div class="line"></div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inorder traversal of original binary tree is: "</span> &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">	printInorder(tree);</div><div class="line"></div><div class="line">	Node *clone = cloneTree(tree);</div><div class="line"></div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\nInorder traversal of cloned binary tree is: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	printInorder(clone);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、在原二叉树上插入新节点后再删除"><a href="#3、在原二叉树上插入新节点后再删除" class="headerlink" title="3、在原二叉树上插入新节点后再删除"></a>3、在原二叉树上插入新节点后再删除</h3><p>思想同单链表操作一样，但这里要注意节点间的相对关系，在创建新节点时要正确建立该节点与父节点原左右孩子的关系。具体如图示：</p>
<p><img src="http://7xlnl2.com1.z0.glb.clouddn.com/post57-1.jpg" alt="图3"></p>
<p>具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></div><div class="line">	<span class="keyword">int</span> key;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>, *<span class="title">random</span>;</span></div><div class="line">	Node(<span class="keyword">int</span> k, Node* l, Node* r, Node* rand): key(k), left(l), right(r), random(rand) &#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 层次遍历</span></div><div class="line"><span class="comment">// [a, b] 表示 key 为 a 的节点 random 指针指向 key 为 b 的节点</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInorder</span><span class="params">(Node* node)</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(node == <span class="literal">NULL</span>)</div><div class="line">		<span class="keyword">return</span> ;</div><div class="line"></div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"[ "</span> &lt;&lt; node-&gt;key &lt;&lt; <span class="string">" "</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(node-&gt;random == <span class="literal">NULL</span>)</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL ], "</span>;</div><div class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; node-&gt;random-&gt;key &lt;&lt; <span class="string">" ], "</span>;</div><div class="line"></div><div class="line">	printInorder(node-&gt;left);</div><div class="line">	printInorder(node-&gt;right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 复制每个节点及左右孩子（不包含随机指针），并返回复制后的节点 </span></div><div class="line"><span class="function">Node* <span class="title">copyLeftRightNode</span><span class="params">(Node* treeNode)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(treeNode == <span class="literal">NULL</span>)</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 在根节点与左孩子之间插入一个新节点</span></div><div class="line">	Node* left = treeNode-&gt;left;</div><div class="line">	treeNode-&gt;left = <span class="keyword">new</span> Node(treeNode-&gt;key, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">	treeNode-&gt;left-&gt;left = left;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(left != <span class="literal">NULL</span>) &#123;</div><div class="line">		left-&gt;left = copyLeftRightNode(left);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 复制后的左节点右孩子指向其父节点右孩子复制后得到的节点</span></div><div class="line">	treeNode-&gt;left-&gt;right = copyLeftRightNode(treeNode-&gt;right);</div><div class="line">	<span class="keyword">return</span> treeNode-&gt;left;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 复制随机指针</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyRandomNode</span><span class="params">(Node* treeNode, Node* cloneNode)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(treeNode == <span class="literal">NULL</span>)</div><div class="line">		<span class="keyword">return</span> ;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(treeNode-&gt;random != <span class="literal">NULL</span>)</div><div class="line">		cloneNode-&gt;random = treeNode-&gt;random-&gt;left;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		cloneNode-&gt;random = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(treeNode-&gt;left != <span class="literal">NULL</span> &amp;&amp; cloneNode-&gt;left != <span class="literal">NULL</span>)</div><div class="line">		copyRandomNode(treeNode-&gt;left-&gt;left, cloneNode-&gt;left-&gt;left);</div><div class="line">	copyRandomNode(treeNode-&gt;right, cloneNode-&gt;right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 恢复原来的二叉树，也即分离出新复制的二叉树</span></div><div class="line"><span class="comment">// 因为右孩子关系保持正确，因此只需更新左孩子关系</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">restoreTreeLeftNode</span><span class="params">(Node* treeNode, Node* cloneNode)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(treeNode == <span class="literal">NULL</span>)</div><div class="line">		<span class="keyword">return</span> ;</div><div class="line">	<span class="keyword">if</span>(cloneNode-&gt;left != <span class="literal">NULL</span>) &#123;</div><div class="line">		Node* cloneLeft = cloneNode-&gt;left-&gt;left;</div><div class="line">		treeNode-&gt;left = treeNode-&gt;left-&gt;left;</div><div class="line">		cloneNode-&gt;left = cloneLeft;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		treeNode-&gt;left = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	restoreTreeLeftNode(treeNode-&gt;left, cloneNode-&gt;left);</div><div class="line">	restoreTreeLeftNode(treeNode-&gt;right, cloneNode-&gt;right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 复制整棵二叉树</span></div><div class="line"><span class="function">Node* <span class="title">cloneTree</span><span class="params">(Node* treeNode)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(treeNode == <span class="literal">NULL</span>)</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	Node* cloneNode = copyLeftRightNode(treeNode);</div><div class="line">	copyRandomNode(treeNode, cloneNode);</div><div class="line">	restoreTreeLeftNode(treeNode, cloneNode);</div><div class="line">	<span class="keyword">return</span> cloneNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">/*</span></div><div class="line">	Node* tree = new Node(1);</div><div class="line">	tree-&gt;left = new Node(2);</div><div class="line">	tree-&gt;right = new Node(3);</div><div class="line">	tree-&gt;left-&gt;left = new Node(4);</div><div class="line">	tree-&gt;left-&gt;right = new Node(5);</div><div class="line">	tree-&gt;random = tree-&gt;left-&gt;right;</div><div class="line">	tree-&gt;left-&gt;left-&gt;random = tree;</div><div class="line">	tree-&gt;left-&gt;right-&gt;random = tree-&gt;right;</div><div class="line">*/</div><div class="line">	Node *tree = <span class="keyword">new</span> Node(<span class="number">10</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Node *n2 = <span class="keyword">new</span> Node(<span class="number">6</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Node *n3 = <span class="keyword">new</span> Node(<span class="number">12</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Node *n4 = <span class="keyword">new</span> Node(<span class="number">5</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Node *n5 = <span class="keyword">new</span> Node(<span class="number">8</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Node *n6 = <span class="keyword">new</span> Node(<span class="number">11</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Node *n7 = <span class="keyword">new</span> Node(<span class="number">13</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Node *n8 = <span class="keyword">new</span> Node(<span class="number">7</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    Node *n9 = <span class="keyword">new</span> Node(<span class="number">9</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    tree-&gt;left = n2;</div><div class="line">    tree-&gt;right = n3;</div><div class="line">    tree-&gt;random = n2;</div><div class="line">    n2-&gt;left = n4;</div><div class="line">    n2-&gt;right = n5;</div><div class="line">    n2-&gt;random = n8;</div><div class="line">    n3-&gt;left = n6;</div><div class="line">    n3-&gt;right = n7;</div><div class="line">    n3-&gt;random = n5;</div><div class="line">    n4-&gt;random = n9;</div><div class="line">    n5-&gt;left = n8;</div><div class="line">    n5-&gt;right = n9;</div><div class="line">    n5-&gt;random = tree;</div><div class="line">    n6-&gt;random = n9;</div><div class="line">    n9-&gt;random = n8;</div><div class="line"></div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"traversal of original binary tree is: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	printInorder(tree);</div><div class="line"></div><div class="line">	Node *clone = cloneTree(tree);</div><div class="line"></div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\ntraversal of cloned binary tree is: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	printInorder(clone);</div><div class="line"></div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、包含随机指针的单链表的深度拷贝&quot;&gt;&lt;a href=&quot;#一、包含随机指针的单链表的深度拷贝&quot; class=&quot;headerlink&quot; title=&quot;一、包含随机指针的单链表的深度拷贝&quot;&gt;&lt;/a&gt;一、包含随机指针的单链表的深度拷贝&lt;/h3&gt;&lt;p&gt;最近遇到一道很有趣的
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="algorithm" scheme="http://blog.yinwoods.work/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组(suffix Array)学习</title>
    <link href="http://blog.yinwoods.work/2016/10/16/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://blog.yinwoods.work/2016/10/16/后缀数组学习/</id>
    <published>2016-10-15T16:00:00.000Z</published>
    <updated>2017-07-26T10:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-后缀（Suffix）"><a href="#什么是-后缀（Suffix）" class="headerlink" title="什么是 后缀（Suffix）"></a>什么是 后缀（Suffix）</h3><p>S是一个长度为 N 的字符串，那么定义S的第 i 个后缀就是S的子串 <code>S[i...n-1]</code></p>
<h3 id="什么是-后缀数组（Suffix-Array）"><a href="#什么是-后缀数组（Suffix-Array）" class="headerlink" title="什么是 后缀数组（Suffix Array）"></a>什么是 后缀数组（Suffix Array）</h3><p>后缀数组作为一种数据结构，被广泛应用于数据压缩、生物信息学等领域。通俗地说后缀数组被应用于<code>任何处理字符串与字符串匹配的场合</code>。</p>
<p>后缀数组是各个排序后的后缀的起始位置组成的数组。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>当 S = abaab 时。</p>
<p>所有的后缀如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0.</span> abaab</div><div class="line"><span class="number">1.</span> baab</div><div class="line"><span class="number">2.</span> aab</div><div class="line"><span class="number">3.</span> ab</div><div class="line"><span class="number">4.</span> b</div></pre></td></tr></table></figure>
<p>依据字符串的比较对后缀进行排序后得到：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">2.</span> aab</div><div class="line"><span class="number">3.</span> ab</div><div class="line"><span class="number">0.</span> abaab</div><div class="line"><span class="number">4.</span> b</div><div class="line"><span class="number">1.</span> baab</div></pre></td></tr></table></figure>
<p>因此字符串S的后缀数组为： <code>(2, 3, 0, 4, 1)</code></p>
<h3 id="后缀数组的构造"><a href="#后缀数组的构造" class="headerlink" title="后缀数组的构造"></a>后缀数组的构造</h3><h4 id="O-N2logN-构造法"><a href="#O-N2logN-构造法" class="headerlink" title="O(N2logN)  构造法"></a>O(N2logN)  构造法</h4><p>这是最朴素的构造方法效率，即获取所有后缀并使用O(NlogN)的排序算法如快排或者合并排序对这些后缀进行排序。而构造法的时间复杂度是O(N2logN)而不是O(NlogN)的原因是排序过程中两个后缀的比较复杂度为O(N)。下面我们将把比较的复杂度从O(N)降为O(logN)。</p>
<h4 id="O-N-log2-N-构造法"><a href="#O-N-log2-N-构造法" class="headerlink" title="O(N log2 N) 构造法"></a>O(N log2 N) 构造法</h4><p>比较的复杂度能够从O(N)降为O(logN)依赖于后缀的特性：这些后缀并不是随机的，而是同属于一个字符串的后缀，也就是说这些后缀有相同的公共部分可以供我们利用。</p>
<p>下面用示例说明。我们以所有后缀的首字母为基准排序，并对这些首字母赋予一个 rank 值代表他们之间的大小关系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0.</span> a|baab</div><div class="line"><span class="number">0.</span> a|ab</div><div class="line"><span class="number">0.</span> a|b</div><div class="line"><span class="number">1.</span> b|aab</div><div class="line"><span class="number">1.</span> b|</div></pre></td></tr></table></figure>
<p>如上，以 | 左侧字符串为比较基准，字符串前的数字表示 | 左侧字符串对应的 rank。由此，rank(a) = 0， rank(b) = 1。</p>
<p>我们取两个字符进行比较时，比较分两步。首先比较第一个字符，如果相等则继续比较第二个字符。</p>
<p>1、对于 abaab 和 baab，因为二者首字母 rank 值已知且不同，因此 abaab 排序在 baab 之前。</p>
<p>2、对于 abaab 和 aab，因为而这首字母 rank 值已知且相同，因此继续看第二个字符，两者的第二个字符不同且 rank 值已知，所以 aab 排在 abaab 之前。</p>
<p>通过上面两个步骤的解析可以发现，在比较所有后缀的第一个字符之后，我们就已经获得了整个字符串 S 的所有字符的 rank 值。（因为所有后缀的首字符组在一起恰好为字符串S，联想后缀的定义即S从i(0 &lt;= i &lt; len(s))到S的最后一个字符所组成的字符串集合）</p>
<p>对于没有第二个字符的字符串我们认为它的第二部分 rank 值为最小值，这里设其为-1。例如 b 只有一个字符，因此它的前两个字符 rank 对就为（1， -1）</p>
<p>现在我们尝试以两个字符作为比较基准，有：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0.</span> aa|b</div><div class="line"><span class="number">1.</span> ab|aab</div><div class="line"><span class="number">1.</span> ab|</div><div class="line"><span class="number">2.</span> b|</div><div class="line"><span class="number">2.</span> ba|ab</div></pre></td></tr></table></figure>
<p>综上所述，对于字符串下次比较，我们选取4个字符，而4个字符的比较又可分为两部分：前两个字符和后两个字符。这又回到了上一步的过程。因此比较两个字符串时，我们只需比较前1、2、4、8、…、log(len(s))个字符。</p>
<p>下面是代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bits/stdc++.h"</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="comment">// suffixRank 保存每次遍历过程中每个字符串的Rank值 </span></div><div class="line"><span class="comment">// suffixRank[i][j] 代表第 i 次遍历，第 j 个后缀的 rank </span></div><div class="line"></div><div class="line"><span class="keyword">int</span> suffixRank[<span class="number">20</span>][<span class="keyword">int</span>(<span class="number">1E6</span>)];</div><div class="line"></div><div class="line"><span class="comment">// 示例： "abaab" </span></div><div class="line"><span class="comment">// 对应的后缀数组： (2, 3, 0, 4, 1) </span></div><div class="line"><span class="comment">// 创建一个保存每个后缀 rank 值序列的结构体。 </span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myTuple</span> &#123;</span>  </div><div class="line">    <span class="keyword">int</span> originalIndex;   <span class="comment">// 保存原始后缀首字母的序列号</span></div><div class="line">    <span class="keyword">int</span> firstHalf;       <span class="comment">// 保存后缀前半部分的 rank 值</span></div><div class="line">    <span class="keyword">int</span> secondHalf;      <span class="comment">// 保存后缀后半部分的 rank 值</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 后缀比较函数，时间复杂度O(1)</span></div><div class="line"><span class="comment">// 首先 a 的 firstHalf 是否与 b 的 firstHalf 相等</span></div><div class="line"><span class="comment">// 如果相等，则比较 secondHalf</span></div><div class="line"><span class="comment">// 否则比较结果取决于 firstHalf 的 rank 值大小</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(myTuple a, myTuple b)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span>(a.firstHalf == b.firstHalf) <span class="keyword">return</span> a.secondHalf &lt; b.secondHalf;  </div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.firstHalf &lt; b.firstHalf;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="comment">// 输入字符串 S </span></div><div class="line">	<span class="comment">// 保存 S 的长度到 N 中</span></div><div class="line"></div><div class="line">    <span class="built_in">string</span> s; <span class="built_in">cin</span> &gt;&gt; s;</div><div class="line">    <span class="keyword">int</span> N = s.size();</div><div class="line">	</div><div class="line">	<span class="comment">// 初始化 每个后缀的首字母 rank 值作为对应后缀的 rank 值 </span></div><div class="line">	<span class="comment">// 对于单字母 rank 值，以该子母与 a 差距作为 rank，因此 'a' = 0, 'b' = 1, 'c' = 2, ... ,'z' = 25</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</div><div class="line">        suffixRank[<span class="number">0</span>][i] = s[i] - <span class="string">'a'</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 创建每个后缀的 元组 数组</span></div><div class="line"></div><div class="line">    myTuple L[N];</div><div class="line">	</div><div class="line">	<span class="comment">// 遍历 log(n) 次，直到所有的后缀排序完毕</span></div><div class="line">	<span class="comment">// 'stp' 保存当前遍历次数</span></div><div class="line">	<span class="comment">// 'cnt' 保存将被比较的后缀长度 </span></div><div class="line"></div><div class="line">	<span class="comment">// 每次遍历， 我们用上一次遍历获得的值初始化每个后缀数组的元组</span></div><div class="line">	</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cnt = <span class="number">1</span>, stp = <span class="number">1</span>; cnt &lt; N; cnt *= <span class="number">2</span>, ++stp) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">            L[i].firstHalf = suffixRank[stp - <span class="number">1</span>][i];</div><div class="line">            L[i].secondHalf = i + cnt &lt; N ? suffixRank[stp - <span class="number">1</span>][i + cnt] : <span class="number">-1</span>;</div><div class="line">            L[i].originalIndex = i;</div><div class="line">        &#125;</div><div class="line">		</div><div class="line">		<span class="comment">// 以 元组 为基准对 元组数组 排序</span></div><div class="line"></div><div class="line">        sort(L, L + N, cmp);</div><div class="line">		</div><div class="line">		<span class="comment">// 排序后，另排序最靠前的 rank 值初始化为0 </span></div><div class="line">        <span class="comment">// Initialize rank for rank 0 suffix after sorting to its original index</span></div><div class="line">        <span class="comment">// in suffixRank array</span></div><div class="line"></div><div class="line">        suffixRank[stp][L[<span class="number">0</span>].originalIndex] = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, currRank = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">			</div><div class="line">			<span class="comment">// 比较第 i 个后缀和第 i-1 个后缀</span></div><div class="line">			<span class="comment">// 如果二者相等，则将第 i-1 个后缀的 rank 值赋给第 i 个后缀</span></div><div class="line">			<span class="comment">// 否则第 i 个后缀的 rank 为第 i-1 个后缀的 rank 值加1 </span></div><div class="line"></div><div class="line">            <span class="keyword">if</span>(L[i - <span class="number">1</span>].firstHalf != L[i].firstHalf || L[i - <span class="number">1</span>].secondHalf != L[i].secondHalf)</div><div class="line">                ++currRank;</div><div class="line"></div><div class="line">            suffixRank[stp][L[i].originalIndex] = currRank;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 输出后缀数组 </span></div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">cout</span> &lt;&lt; L[i].originalIndex &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="后缀数组的应用"><a href="#后缀数组的应用" class="headerlink" title="后缀数组的应用"></a>后缀数组的应用</h3><p>1、结合LCP（Longest Common Prefix）</p>
<p>2、模式匹配</p>
<p>3、 查找最长重复子串</p>
<p>4、 查找最长公共子串</p>
<p>5、 查找最长回文子串</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>1、<a href="https://www.hackerrank.com/challenges/string-function-calculation/topics/two-pointer-technique" target="_blank" rel="external">String Function Calculation Topics</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是-后缀（Suffix）&quot;&gt;&lt;a href=&quot;#什么是-后缀（Suffix）&quot; class=&quot;headerlink&quot; title=&quot;什么是 后缀（Suffix）&quot;&gt;&lt;/a&gt;什么是 后缀（Suffix）&lt;/h3&gt;&lt;p&gt;S是一个长度为 N 的字符串，那么定义S的第
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="algorithm, data structure" scheme="http://blog.yinwoods.work/tags/algorithm-data-structure/"/>
    
  </entry>
  
  <entry>
    <title>首尾指针法</title>
    <link href="http://blog.yinwoods.work/2016/10/16/%E9%A6%96%E5%B0%BE%E6%8C%87%E9%92%88%E6%B3%95/"/>
    <id>http://blog.yinwoods.work/2016/10/16/首尾指针法/</id>
    <published>2016-10-15T16:00:00.000Z</published>
    <updated>2017-07-26T10:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>首尾指针法多应用于在已排序的数组中实现O(N)的查找。</p>
<p>例如：给定一个整数k，对于两个递增数组，找到(i, j)使得 a 中的 i 位置与 b 中的 j 位置满足 a[i] + b[j] = k。<br>对于这种问题，我们往往可以取 a 中的第i位及 b 中第j位，依次相加并根据相加结果与数值 k 的大小来决定i, j的移动方向。</p>
<p>具体代码如下：</p>
<pre><code>#!CPP
while (i &lt; a.size()) {
    while(a[i] + b[j] &gt; X &amp;&amp; j &gt; 0) j--;
    if (a[i] + b[j] == X) writeAnswer(i, j);
    i++;
}
</code></pre><p>问题变形：</p>
<p>1、对于无重复元素的数组 a，问存在多少种三个数相加，和为定值k的情况。</p>
<blockquote>
<p>解答：先对数组排序，外部循环遍历a，并在循环内部找a[p] + a[q] = k - a[i]的情况。其中 p,q 的寻找即利用首尾指针法。</p>
</blockquote>
<p>2、对于无重复元素的数组 a，问存在多少种两个数相减，和为定值k的情况。</p>
<blockquote>
<p>解答：先对数组排序，外部循环遍历a，判断a[i] + k是否在数组a中即可，判断可以利用set来实现log(N)的时间复杂度，因此该算法的时间复杂度为O(NlogN)。</p>
<p>解答： 更高效的方法是取i = 0, j = 1, 当 a[j] - a[i] &gt; k 时，++i；当a[j] - a[i] &lt; k时，++j;</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首尾指针法多应用于在已排序的数组中实现O(N)的查找。&lt;/p&gt;
&lt;p&gt;例如：给定一个整数k，对于两个递增数组，找到(i, j)使得 a 中的 i 位置与 b 中的 j 位置满足 a[i] + b[j] = k。&lt;br&gt;对于这种问题，我们往往可以取 a 中的第i位及 b 中第
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="algorithm" scheme="http://blog.yinwoods.work/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>实习总结</title>
    <link href="http://blog.yinwoods.work/2016/09/26/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.yinwoods.work/2016/09/26/实习总结/</id>
    <published>2016-09-25T16:00:00.000Z</published>
    <updated>2017-07-26T10:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>从2015年1月底到2016年8月底在某二手车服务平台公司北京研发部实习了也算有半年的时间（去除中间回校答辩的一个月），从刚进入团队时的四五个人到离开时的20+人队伍，也算是从一个实习生角度见证了一个公司的成长过程。</p>
<h3 id="实习之初："><a href="#实习之初：" class="headerlink" title="实习之初："></a>实习之初：</h3><p>接手的工作是尽可能多地匹配两个车型库中的车型，提高车型匹配率。说实话这个工作我做地很痛苦，因为用C++写的，本身开发速度就比较慢，而且刚进入团队一方面是想展现出自己的实力；另一方面团队领导也对我不够信任，给我的感觉就是他们认为我在偷懒，而事实是我投入了大量的时间在其中。写完了一版之后就会发现有各种case要单独处理，当然出现这种问题很大的原因是我在动手写项目之前没有认真考虑过整个项目的结构以及各种可能会面对的case，这应该归因于我的经验问题，而不是能力问题。面对这种情况，这个时候摆在面前的选择有：</p>
<p>1、在程序中加各种判断语句针对处理；</p>
<p>2、代码重构；</p>
<p>就我个人而言我更倾向于代码重构，因为能够重新理清思路，避免后续出现的很多坑。但是由于业务需要，boss们更倾向于我快些交付，因此就只能像打补丁一样往原代码里面加各种处理，导致最后整个代码改起来特别吃力，每天花费大把的时间投入其中而取得的效果却微乎其微。而且boss的想法总是想一出是一出，需求来回变换而我又不能重构代码。那段时间自己也很痛苦，后来向boss明确表示自己不想再做这方面的工作了。幸好boss也表示理解，并且这项工作也证明了很难走得通（ <strong> 原因：两个车型库的车型命名差异太大，很难提取共通之处。 </strong> ）</p>
<h3 id="实习之中："><a href="#实习之中：" class="headerlink" title="实习之中："></a>实习之中：</h3><p>因为车型匹配这条路走不通加上我明确表示这项工作让我觉得很痛苦，因此boss给我分配的新任务是爬虫，爬取各大车上网站的数据（主要是每款车的配置价格等数据）。在这之前我学习过一段时间的python，算是入门，其中也涉及到了基础的爬虫抓取，懂得urllib以及beautifulsoup的使用。刚刚接手这个工作还是很惶恐的，好在boss表示交给我的任务是尝试性的，能够爬取更好，不能爬取的话再想别的方法。也正是从这里开始了我边学习边写爬虫的实习之路。</p>
<p>起初刚接手的是<a href="http://www.carking001.com/" target="_blank" rel="external">车王网</a>,记得好像没有什么防爬措施，因此大概花了一周的时间顺利地完成了爬取工作，boss也对我完成的工作比较满意，后面就给我布置了爬取<a href="http://www.che300.com/" target="_blank" rel="external">车300</a>的工作。说到这里就要提到一件比较有趣的事了，因为要求我写的爬虫只需要把相应网站的车型库整体爬下来一次，而不是动态更新，因此写得比较简单，并不涉及并行操作，而每个车型都对应一个唯一的id，所以完全可以启动多个python爬虫脚本，每个脚本爬取一个id范围内的车型信息，这样也算是从某种角度上实现了并行爬取。刚好boss当时对车300数据要的比较急，就让我同时启动10个脚本一起爬，这样一来速度上确实快了很多。但是因为单位时间内大量访问，ip被封了。。。也就是从这里开始学习了各种反-反爬虫的技术。后面又爬了<a href="http://www.dpac.gov.cn/" target="_blank" rel="external">国家质检总局产品缺陷管理中心</a>，新旧页面结构变化很大，且老数据展示及其不规范！不过花了写时间总算是比较像样地实现了。</p>
<p>这段时间公司各项业务也开始起步，招聘了很多新人，并购置了很多服务器。作为一个实习生，运营维护也就成了我工作中的一部分，实现一些定时脚本等等。这里不得不吐槽一下：为什么好多计算机从业人员连装系统都不会啊。。。</p>
<p>期间也在实习中完成了自己的毕业设计，回校答辩。（爬虫跑起来抓取数据的时候我就有时间动手写自己的毕设了，这也算是写爬虫的一个福利吧！）</p>
<h3 id="实习之尾"><a href="#实习之尾" class="headerlink" title="实习之尾"></a>实习之尾</h3><p>本来预计回校一周完成答辩工作的，没想到我们院硬生生地拖了大半个月才开始答辩工作 #_#!。可能是经过前面这段时间的高强度实习，很多知识都没有时间消化，回校这段休闲的时间反而感觉领会了很多东西。期间也帮同学的一个姐姐编写了一个校内抢先预定实验设备的脚本，功能倒是实现了，可以因为用的是 <a href="http://www.seleniumhq.org/" target="_blank" rel="external">selenium</a> + <a href="http://phantomjs.org/" target="_blank" rel="external">phantomjs</a>导致最后速度上还没有人工操作快。。。也算是胎死腹中了吧。</p>
<p>答辩完成后和朋友们一起去云南玩了一周，又回到公司实习，继续做爬虫相关工作。实现了一个定时抓取<a href="">汽车之家</a>的动态增量爬虫，并部署到了公司的服务器上，每个月初定时爬取。</p>
<h3 id="实习总结"><a href="#实习总结" class="headerlink" title="实习总结"></a>实习总结</h3><p>实习过程中自己确实学到了很多，看到了一些优秀程序员的追求已经不再是多少多少钱，而是在愉快地工作中实现自己的价值。让我了解到了优秀的程序员是怎么看待问题以及处理问题的。在获取酬劳的同时也学到了很多知识以及技术，以及一些与hr、boss交流的注意事项。相信对以后从事工作应该也有所帮助。</p>
<p>自己也认真地思考了一下去初创公司的一些长处和缺点，仅供大家参考：</p>
<p>长处：</p>
<p>1、能够和大牛们一起并肩战斗，开拓眼界；</p>
<p>2、团队工作强度大，锻炼多，成长速度快；</p>
<p>3、一人多用，要做各方面的工作；（或许算是缺点-&gt;_-&gt;）</p>
<p>4、和领导接触机会多，能够看到领导是怎么看待问题，怎么处理纠纷的；</p>
<p>5、人际关系简单，同事相处起来没有太多约束；</p>
<p>缺点：</p>
<p>1、缺乏有效的团队管理，开发进度很大程度上靠自我约束以及上级督促；</p>
<p>2、需求来回变换，往往想一出是一出，没有系统地构架；</p>
<p>3、开发工具、语言没有统一要求，整体比较混乱；</p>
<p>回想起实习的那段时间，虽然比较辛苦，但整体还是感觉很快乐，自己也确实成长了许多。感谢实习公司给予我的实习机会以及同事们给予我的指导和帮助！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从2015年1月底到2016年8月底在某二手车服务平台公司北京研发部实习了也算有半年的时间（去除中间回校答辩的一个月），从刚进入团队时的四五个人到离开时的20+人队伍，也算是从一个实习生角度见证了一个公司的成长过程。&lt;/p&gt;
&lt;h3 id=&quot;实习之初：&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="diary" scheme="http://blog.yinwoods.work/categories/diary/"/>
    
    
      <category term="thoughts" scheme="http://blog.yinwoods.work/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title>python中的context manager</title>
    <link href="http://blog.yinwoods.work/2016/08/08/python%E4%B8%AD%E7%9A%84context-manager/"/>
    <id>http://blog.yinwoods.work/2016/08/08/python中的context-manager/</id>
    <published>2016-08-07T16:00:00.000Z</published>
    <updated>2017-07-26T10:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读python进阶类书籍《Intermediate Python》，看到后面有一章讲到<code>context manager</code>，讲的很浅，我也没看懂。于是自己抽时间搜集了网上的一些资料，整理如下：</p>
<p>python中的<code>context manager</code>也叫做上下文管理器，主要功能是确保代码块始终能够得到正确的‘善后’处理。有点像java中的<code>try     ... catch     ... finally     ...</code></p>
<p>对于打开文件读写，我们都知道下面的实现方式更好：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'file'</span>) <span class="keyword">as</span> f:</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">    	print(line)</div></pre></td></tr></table></figure>
<p>但这种方式为什么更好呢？原因在于使用<code>with</code>可以执行<code>context manager</code>的相应函数，确保被打开的文件始终能够被关闭。如果我们自己手动<code>open()</code>、<code>close()</code>则可能会因为中间代码产生的异常导致<code>close()</code>无法执行。因此使用<code>with</code>可以让代码既简洁又有效。</p>
<p>下面接着说一说<code>context manager</code>的功能与用法。</p>
<h3 id="管理资源"><a href="#管理资源" class="headerlink" title="管理资源"></a>管理资源</h3><p><code>context manager</code>最常被用于管理资源，事实上，这也是很多时候我们使用它的原因。</p>
<p>当我们打开一个文件时，程序会占有对应的资源（文件描述符），而资源的管理则由操作系统来完成，也就是说同一时间能够打开的文件或进程是有限的。</p>
<p>例如，运行下面这份代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">files = []</div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100000</span>):</div><div class="line">    files.append(open(<span class="string">'foo.txt'</span>, <span class="string">'w'</span>))</div></pre></td></tr></table></figure>
<p>在mac os或linux上运行这份代码很有可能会产生OSError而导致中断，而在windows上运行程序则可能导致系统直接卡死。</p>
<p>那么问题的原因是什么呢？</p>
<p>答：是<em>内存泄露！</em> 这里的泄露原因是指打开文件后但未关闭。</p>
<p>为了避免对文件操作时产生上述的错误，有两种解决方法：</p>
<blockquote>
<p>1、避免同时打开超过操作系统上限个数个文件；</p>
<p>2、每次打开文件后关闭文件；</p>
</blockquote>
<p>毫无疑问，这里2的操作更好，因为能够更好地实现高层抽象并解决内存泄露问题。</p>
<p>先说1：在unix上<code>ulimit -n</code>可以查看同时打开文件描述符上限，在写代码时确保同时打开的文件数不超过上限值即可。但是这里并没有解决根本问题：内存泄露！</p>
<p>再说2：我们当然可以为上面的代码添加close()函数，可是如果打开文件或者对文件内容处理时产生异常，那么后面的<code>close()</code>就无法被执行，从而导致内存泄露。</p>
<p><code>context manager</code>正是用于处理这种情况的一个接口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> something_that_returns_a_context_manager() <span class="keyword">as</span> my_resource:</div><div class="line">    do_something(my_resource)</div><div class="line">    ...</div><div class="line">    print(<span class="string">'done using my_resource'</span>)</div></pre></td></tr></table></figure>
<p>使用<code>with</code>，我们可以操作任何一个返回上下文管理器的函数（例如内置函数<code>open()</code>）；<code>with</code>能够保证当相应代码块内的代码执行完毕时，始终调用一个包含清理资源的‘善后’函数。这个‘善后’函数就定义在<code>context manager</code>中。</p>
<p>实现一个最简单的context manager只要求包含<code>__enter__()</code>函数以及<code>__exit__()</code>。</p>
<blockquote>
<p><code>__enter__()</code>执行操作并返回被管理的资源；</p>
<p><code>__exit__()</code>则清理资源，无返回。</p>
</blockquote>
<p>例如我们通过以下代码创建一个自己的<code>context manager</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span><span class="params">()</span>:</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename, mode)</span>:</span></div><div class="line">        self.filename = filename</div><div class="line">        self.mode = mode</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        self.open_file = open(self.filename, self.mode)</div><div class="line">        <span class="keyword">return</span> self.open_file</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self)</span>:</span></div><div class="line">        self.open_file.close()</div><div class="line">        </div><div class="line">files = []</div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100000</span>):</div><div class="line">    <span class="keyword">with</span> File(<span class="string">'foo.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</div><div class="line">        files.append(f.write(<span class="string">'foo'</span>))</div></pre></td></tr></table></figure>
<p>这里<code>__enter__()</code>打开文件，并返回；<code>__exit__()</code>则关闭文件。</p>
<h3 id="其他有用的资源管理器"><a href="#其他有用的资源管理器" class="headerlink" title="其他有用的资源管理器"></a>其他有用的资源管理器</h3><p>很多库中也包含资源管理器，例如<code>zipfile.ZipFile</code>、<code>subprocess.Popen</code>、<code>tarfile.TarFile</code>、<code>telnet.Telnet</code>、<code>pathlib.Path</code>等。其实，在使用完资源之后调用<code>close()</code>方法的都是<code>context manager</code>。</p>
<h3 id="关于contextlib"><a href="#关于contextlib" class="headerlink" title="关于contextlib"></a>关于<code>contextlib</code></h3><p><code>contextlib</code>模块包含了许多创建、使用<code>context manager</code>的工具。</p>
<p>例如使用<code>@contextmanager</code>装饰器来创建一个<code>context manager</code>。具体的创建方法是使用<code>@contextmanager</code>来装饰只包含一个<code>yield</code>语句的<code>generator</code>函数。在<code>yield</code>之前的部分都被视为<code>__enter__()</code>函数内容，而之后的部分则是<code>__exit__()</code>函数内容。下面让我们用这种方法来重写<code>File()</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</div><div class="line"></div><div class="line"><span class="meta">@contextmanager</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_file</span><span class="params">(path, mode)</span>:</span></div><div class="line">    the_file = open(path, mode)</div><div class="line">    <span class="keyword">yield</span> the_file</div><div class="line">    the_file.close()</div><div class="line">    </div><div class="line">files = []</div><div class="line"></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100000</span>):</div><div class="line">    <span class="keyword">with</span> open_file(<span class="string">'foo.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</div><div class="line">        files.append(f)</div></pre></td></tr></table></figure>
<p>对比后可以发现使用这种方法的代码更加简洁。</p>
<p>另外有一个很简单的例子可以帮助你理解<code>@contextmanager</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</div><div class="line"></div><div class="line"><span class="meta">@contextmanager</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">"&lt;%s&gt;"</span> % name)</div><div class="line">    <span class="keyword">yield</span></div><div class="line">    print(<span class="string">"&lt;/%s&gt;"</span> % name)</div><div class="line">    </div><div class="line"><span class="keyword">with</span> tag(<span class="string">"h1"</span>):</div><div class="line">    print(<span class="string">"hello, world!"</span>)</div></pre></td></tr></table></figure>
<p>输出：<code>&lt;h1&gt;hello, world!&lt;/h1&gt;</code></p>
<p>另外也可以通过<code>contextlib.ContextDecorator</code>来实现自己的<code>context manager</code>装饰器。例如接着使用上面的例子来说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> ContextDecorator</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">makeparagraph</span><span class="params">(ContextDecorator)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'&lt;p&gt;'</span>)</div><div class="line">        <span class="keyword">return</span> self</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *exc)</span>:</span></div><div class="line">        print(<span class="string">'&lt;/p&gt;'</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        </div><div class="line"><span class="meta">@makeparagraph</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">emit_html</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'Here is some non-HTML'</span>)</div></pre></td></tr></table></figure>
<p>执行<code>emit_html()</code><br>会输出<code>&lt;p&gt;Here is some non-HTML&lt;/p&gt;</code></p>
<h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><blockquote>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-0343/" target="_blank" rel="external">PEP 34</a></p>
</li>
<li><p><a href="https://jeffknupp.com/blog/2016/03/07/python-with-context-managers/" target="_blank" rel="external">Python with Context Managers</a></p>
</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在读python进阶类书籍《Intermediate Python》，看到后面有一章讲到&lt;code&gt;context manager&lt;/code&gt;，讲的很浅，我也没看懂。于是自己抽时间搜集了网上的一些资料，整理如下：&lt;/p&gt;
&lt;p&gt;python中的&lt;code&gt;contex
    
    </summary>
    
      <category term="coding" scheme="http://blog.yinwoods.work/categories/coding/"/>
    
    
      <category term="python" scheme="http://blog.yinwoods.work/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫requests登录解决422错误</title>
    <link href="http://blog.yinwoods.work/2016/07/27/python%E7%88%AC%E8%99%ABrequests%E7%99%BB%E5%BD%95%E8%A7%A3%E5%86%B3422%E9%94%99%E8%AF%AF/"/>
    <id>http://blog.yinwoods.work/2016/07/27/python爬虫requests登录解决422错误/</id>
    <published>2016-07-26T16:00:00.000Z</published>
    <updated>2017-07-26T10:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>小伙伴<a href="http://blog.csdn.net/cumtcyf" target="_blank" rel="external">崔崔</a>今天要爬取<a href="http://ucar.act.buaa.edu.cn/users/sign_in" target="_blank" rel="external">北航ACT实验室的车联网</a>的信息，已有账号密码。模拟登录使用的是python的requests.session().post(),通过chrome的network观察post的表单数据，发现有一个<code>authenticity_token</code>，这个数据是每次刷网页动态生成的，存放在页面header的meta标签中，问题不大，直接用beautifulsoup获取就可以了。</p>
<p>问题出现在post之后，总是得到HTTP 422错误。通过查询了解到这里的422错误是指验证错误，可是token是即时获取的，其他信息也是完全按照表单要求填写，并且对提交数据进行了urlencode并使用<code>gbk</code>encode，实在是想不通原因。然后通过神奇的谷歌居然搜到了相同问题的博客。。。连代码都写得和我的惊人的相似。。。我都开始怀疑是不是和我爬的同一个网站了。。。</p>
<p>正确的爬取姿势是带着cookie验证，我猜这里的<code>authenticity_token</code>与cookie是相关联的，因为爬取时没带上cookie，所以无法验证成功。如果想要带上cookie只需使用<code>requests.Session()</code>来post即可。</p>
<p><a href="http://docs.python-requests.org/zh_CN/latest/user/advanced.html#advanced" target="_blank" rel="external">requests.Session()简介</a></p>
<p>简单介绍一下：</p>
<p>Session作为一个会话对象，会在同一个Session实例发出所有请求之间保存cookie。其实这里可以类比一下：当你登录淘宝后，短时间内访问淘宝的其他页面，不需要重新登录。</p>
<p>完整的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#author : yinwoods</span></div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    url = <span class="string">'http://ucar.act.buaa.edu.cn/users/sign_in'</span></div><div class="line"></div><div class="line"></div><div class="line">    headers = &#123;</div><div class="line">        <span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span>,</div><div class="line">        <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip,deflate'</span>,</div><div class="line">        <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8'</span>,</div><div class="line">        <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</div><div class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</div><div class="line">        <span class="string">'Host'</span>: <span class="string">'ucar.act.buaa.edu.cn'</span>,</div><div class="line">        <span class="string">'Origin'</span>: <span class="string">'http://ucar.act.buaa.edu.cn'</span>,</div><div class="line">        <span class="string">'Referer'</span>: <span class="string">'http://ucar.act.buaa.edu.cn/stat'</span>,</div><div class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0(X11;Linux x86_64) AppleWebKit/537.36(KHTML, like Gecko) Ubuntu Chromium/51.0.2704.79 Chrome/51.0.2704.79 Safari / 537.36'</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">#先获取页面源码，提取token</span></div><div class="line">    session = requests.Session()</div><div class="line">    html = session.get(url, headers=headers).text</div><div class="line"></div><div class="line">    htmlDoc = BeautifulSoup(html, <span class="string">'html.parser'</span>)</div><div class="line">    token = htmlDoc.find_all(<span class="string">'meta'</span>)[<span class="number">-1</span>][<span class="string">'content'</span>]</div><div class="line"></div><div class="line">    print(token)</div><div class="line"></div><div class="line">    datas = urllib.parse.urlencode(&#123;</div><div class="line">        <span class="string">'utf8'</span>: <span class="string">'✓'</span>,</div><div class="line">        <span class="string">'authenticity_token'</span>: token,</div><div class="line">        <span class="string">'user[username]'</span>: username,</div><div class="line">        <span class="string">'user[password]'</span>: password,</div><div class="line">        <span class="string">'user[remember_me]'</span>: <span class="string">'1'</span>,</div><div class="line">        <span class="string">'commit'</span>: <span class="string">'登录'</span></div><div class="line">    &#125;).encode(<span class="string">'gbk'</span>)</div><div class="line"></div><div class="line">    requests.session().post()</div><div class="line"></div><div class="line">    print(datas)</div><div class="line"></div><div class="line">    print(session.post(url=url, params=datas, headers=headers))</div><div class="line"></div><div class="line">    res = session.get(<span class="string">'http://ucar.act.buaa.edu.cn/users/sign_in'</span>).text</div><div class="line">    print(res)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>打印页面后可以发现登录成功，状态码返回200。事后反思，意识到<code>token+cookie</code>可能这是一种比较通用的验证机制，自己不了解一方面是因为经验不足，另一方面可能就是之前爬的网站大都比较简单（是属于开放类门户网站），能够爬取成功并不代表自己的能力很高。</p>
<p>不过话又说回来自己想学的东西太多了。。。目前在看CSAPP，后面有时间再学习《HTTP权威指南》。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小伙伴&lt;a href=&quot;http://blog.csdn.net/cumtcyf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;崔崔&lt;/a&gt;今天要爬取&lt;a href=&quot;http://ucar.act.buaa.edu.cn/users/sign_in&quot; t
    
    </summary>
    
      <category term="myshare" scheme="http://blog.yinwoods.work/categories/myshare/"/>
    
    
      <category term="python, 爬虫" scheme="http://blog.yinwoods.work/tags/python-%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
